# Основы веб-модуля и создание веб-сервера

## Введение в веб-модуль Node.js

### Обзор типовой архитектуры веб-приложений

#### Основные Компоненты Веб-Архитектуры

-   **Клиентская Часть (Front-end):** Это пользовательский интерфейс веб-приложения, с которым взаимодействует конечный пользователь. Она обычно состоит из HTML, CSS и JavaScript, обеспечивая визуальное представление данных и интерактивность.
-   **Серверная Часть (Back-end):** Включает сервер, приложение и базу данных. Сервер принимает запросы от клиентской части, обрабатывает их (часто с взаимодействием с базой данных) и отправляет обратно ответы.

#### Шары Веб-Архитектуры

-   **Презентационный Шар (Presentation Layer):** Это то, что видит пользователь. Этот слой обеспечивает пользовательский интерфейс и управление пользовательскими взаимодействиями. В контексте Node.js это может включать шаблоны, созданные с помощью таких инструментов, как EJS или Pug.
-   **Шар Бизнес-Логики (Business Logic Layer):** Содержит всю логику, необходимую для работы приложения. Это включает в себя обработку данных, которые пользователь вводит через интерфейс, и подготовку этих данных для презентационного шара или для сохранения в базе данных.
-   **Шар Данных (Data Layer):** Этот слой отвечает за хранение, извлечение и управление данными. В веб-приложениях это часто реализуется с помощью систем управления базами данных, таких как MySQL, PostgreSQL или MongoDB.

#### Сервер и Серверные Сценарии

-   **Node.js как Сервер:** В Node.js сервер создается для обработки клиентских запросов. Он может обслуживать статические файлы, обрабатывать формы, взаимодействовать с базой данных и многое другое.
-   **Работа с HTTP-запросами и маршрутизацией:** В Node.js можно легко настроить маршрутизацию для обработки различных запросов (GET, POST, PUT, DELETE) и динамически генерировать ответы на основе этих запросов.

#### Дополнительные Аспекты Архитектуры

-   **Асинхронное Программирование и Callbacks:** Одной из ключевых особенностей Node.js является его асинхронная природа, позволяющая обрабатывать множество запросов одновременно.
-   **Модульность и Пакеты:** Использование модулей и пакетного менеджера NPM позволяет эффективно управлять зависимостями и расширять функциональность приложения.
-   **Безопасность и Оптимизация:** Важные аспекты веб-приложений, включающие в себя аутентификацию, авторизацию, шифрование данных и оптимизацию производительности.

## **Создание простого веб-сервера**

### Создание Простого Веб-Сервера на Node.js

#### Инициализация Node.js проекта

Перед созданием сервера необходимо инициализировать Node.js проект:

1. **Создайте папку для вашего проекта** и откройте её в терминале.
2. **Инициализируйте Node.js проект**: выполните команду `npm init` и следуйте указаниям для создания файла `package.json`. Этот файл будет содержать информацию о проекте и его зависимостях.

#### Создание Основного Файла Сервера

1. **Создайте файл для вашего сервера**, например, `server.js`.
2. **Откройте этот файл в текстовом редакторе** или IDE.

#### Написание Кода Сервера

1. **Подключите встроенный модуль HTTP**:

    ```javascript
    const http = require("http");
    ```

2. **Создайте HTTP-сервер**:

    ```javascript
    const server = http.createServer((request, response) => {
        // Здесь будет обработка запросов
    });
    ```

    - Функция `createServer` принимает коллбэк, который вызывается каждый раз, когда сервер получает новый запрос. Аргументы `request` и `response` представляют собой объекты запроса и ответа.

3. **Напишите логику для обработки запросов**. Например, отправим простой текстовый ответ:

    ```javascript
    server.on("request", (request, response) => {
        response.writeHead(200, { "Content-Type": "text/plain" });
        response.end("Привет, мир!");
    });
    ```

    - Метод `writeHead` используется для установки статуса ответа и его заголовков.
    - Метод `end` заканчивает ответ, отправляя данные.

#### Запуск Сервера

1. **Укажите порт для прослушивания сервером**:

    ```javascript
    const port = 3000;
    server.listen(port, () => {
        console.log(`Сервер запущен на http://localhost:${port}/`);
    });
    ```

    - Метод `listen` запускает HTTP-сервер, который прослушивает входящие соединения на указанном порту.

### Обработка HTTP-запросов.

#### Основы обработки HTTP-запросов

После создания базового сервера на Node.js, важно уметь обрабатывать различные типы HTTP-запросов. Это включает в себя GET, POST, PUT и DELETE. В каждом случае, сервер должен распознавать тип запроса и выполнять соответствующие действия.

#### Реализация обработки разных HTTP-методов

1. **GET запросы**:

    - Обычно используются для получения данных.
    - Сервер может возвращать статический контент, например HTML-страницы, или динамически генерированные данные.

2. **POST запросы**:

    - Используются для отправки данных на сервер, например, из HTML-форм.
    - В Node.js для чтения данных тела запроса необходимо прослушивать события 'data' и 'end' потока запроса.

3. **PUT запросы**:

    - Этот тип запроса обычно используется для обновления существующих данных на сервере.
    - Подобно POST, требуется чтение тела запроса для получения отправленных данных.

4. **DELETE запросы**:

    - Используются для удаления данных на сервере.
    - Сервер обычно обрабатывает эти запросы, удаляя данные и отправляя подтверждение об успешном удалении.

#### Пример кода для обработки разных типов запросов

```javascript
const server = http.createServer((request, response) => {
    const { method, url } = request;

    if (method === "GET") {
        console.log(`GET запрос на ${url}`);
    } else if (method === "POST" || method === "PUT") {
        let body = "";
        request.on("data", (chunk) => {
            body += chunk.toString();
        });
        request.on("end", () => {
            console.log(`Тело запроса: ${body}`);
            // Можно добавить парсинг JSON здесь, если ожидается JSON
            // const jsonData = JSON.parse(body);
        });
    } else if (method === "PUT") {
        // Обработка PUT запроса
    } else if (method === "DELETE") {
        console.log(`DELETE запрос на ${url}`);
    }
});
```

#### Обработка JSON в запросах

Для обработки JSON в POST и PUT запросах:

1. Соберите данные из потока запроса.
2. Используйте `JSON.parse()` для преобразования полученных данных в объект JavaScript.

```javascript
if (method === "POST" || method === "PUT") {
    let body = "";
    request.on("data", (chunk) => {
        body += chunk.toString();
    });
    request.on("end", () => {
        const data = JSON.parse(body);
        // Обработка данных data
    });
}
```

#### Отправка HTTP-ответов

Разобравшись с обработкой разных типов HTTP-запросов, теперь давайте рассмотрим, как отправлять HTTP-ответы из вашего Node.js сервера.

Чтобы отправить HTTP-ответ из вашего сервера, вы можете использовать методы объекта `response`, который представляет собой ответ на запрос. Вот примеры отправки разных типов ответов:

```javascript
const http = require("http");

const server = http.createServer((request, response) => {
    const { method, url } = request;

    if (method === "GET") {
        // Обработка GET запросов
        if (url === "/api/data") {
            // Пример отправки JSON-ответа для GET
            const jsonData = { message: "Это GET JSON-ответ" };
            response.writeHead(200, { "Content-Type": "application/json" });
            response.end(JSON.stringify(jsonData));
        } else {
            // Обработка других GET запросов
            response.writeHead(404, { "Content-Type": "text/plain" });
            response.end("Страница не найдена");
        }
    } else if (method === "POST") {
        // Обработка POST запросов
        if (url === "/api/create") {
            // Пример обработки POST данных
            let body = "";
            request.on("data", (chunk) => {
                body += chunk.toString();
            });
            request.on("end", () => {
                // В body содержатся данные POST запроса, которые можно обработать
                console.log(`Данные POST запроса: ${body}`);
                // Отправка успешного JSON-ответа для POST
                const jsonData = { message: "Данные успешно сохранены" };
                response.writeHead(200, { "Content-Type": "application/json" });
                response.end(JSON.stringify(jsonData));
            });
        } else {
            // Обработка других POST запросов
            response.writeHead(404, { "Content-Type": "text/plain" });
            response.end("Страница не найдена");
        }
    } else if (method === "PUT") {
        // Обработка PUT запросов
        if (url === "/api/update") {
            // Пример обработки PUT данных
            let body = "";
            request.on("data", (chunk) => {
                body += chunk.toString();
            });
            request.on("end", () => {
                // В body содержатся данные PUT запроса, которые можно обработать
                console.log(`Данные PUT запроса: ${body}`);
                // Отправка успешного JSON-ответа для PUT
                const jsonData = { message: "Данные успешно обновлены" };
                response.writeHead(200, { "Content-Type": "application/json" });
                response.end(JSON.stringify(jsonData));
            });
        } else {
            // Обработка других PUT запросов
            response.writeHead(404, { "Content-Type": "text/plain" });
            response.end("Страница не найдена");
        }
    } else if (method === "DELETE") {
        // Обработка DELETE запросов
        if (url === "/api/delete") {
            // Пример обработки DELETE запроса
            console.log("Запрос на удаление данных");
            // Отправка успешного JSON-ответа для DELETE
            const jsonData = { message: "Данные успешно удалены" };
            response.writeHead(200, { "Content-Type": "application/json" });
            response.end(JSON.stringify(jsonData));
        } else {
            // Обработка других DELETE запросов
            response.writeHead(404, { "Content-Type": "text/plain" });
            response.end("Страница не найдена");
        }
    } else {
        // Обработка других методов (например, PATCH, OPTIONS и др.)
        response.writeHead(405, { "Content-Type": "text/plain" });
        response.end("Метод не поддерживается");
    }
});

const port = 3000;
server.listen(port, () => {
    console.log(`Сервер запущен на http://localhost:${port}/`);
});
```

## **Расширенные возможности веб-сервера**

### Управление маршрутами

#### Основные концепции

1. **Маршрутизация (Routing):** Процесс определения того, как сервер должен реагировать на клиентские запросы, в частности, на URL и HTTP-методы (GET, POST и т.д.). Маршрутизация позволяет организовать логику обработки разных запросов в зависимости от URL и метода.
2. **Маршруты и обработчики маршрутов:** Маршрут — это комбинация URL-пути и HTTP-метода. Каждому маршруту может быть присвоен обработчик, который выполняет определенную логику при срабатывании этого маршрута.

#### Реализация маршрутизации

Простой пример маршрутизации без использования сторонних фреймворков в Node.js:

```javascript
const http = require("http");

const server = http.createServer((request, response) => {
    const { method, url } = request;

    // Маршрут для главной страницы
    if (url === "/" && method === "GET") {
        response.writeHead(200, { "Content-Type": "text/html" });
        response.end("<h1>Главная страница</h1>");
    }
    // Маршрут для API
    else if (url.startsWith("/api") && method === "GET") {
        response.writeHead(200, { "Content-Type": "application/json" });
        response.end(JSON.stringify({ message: "Данные с API" }));
    }
    // Обработка неизвестных маршрутов
    else {
        response.writeHead(404, { "Content-Type": "text/plain" });
        response.end("404 Страница не найдена");
    }
});

server.listen(3000, () => {
    console.log("Сервер запущен на http://localhost:3000");
});
```

#### Парсинг URL

Для более сложной маршрутизации важно уметь разбирать URL-адреса на составляющие (путь, параметры запроса и т.д.). Это можно сделать с помощью встроенного модуля `url`.

```javascript
const http = require("http");
const url = require("url");

const server = http.createServer((request, response) => {
    const parsedUrl = url.parse(request.url, true); // Второй аргумент true для парсинга параметров запроса

    const path = parsedUrl.pathname; // Путь URL
    const trimmedPath = path.replace(/^\/+|\/+$/g, ""); // Удаление слэшей в начале и конце

    // Определение обработчика в зависимости от пути
    let chosenHandler;
    if (trimmedPath === "api/data") {
        chosenHandler = handlers.api;
    } else {
        chosenHandler = handlers.notFound;
    }

    // Вызов обработчика
    chosenHandler(request, response);
});

// Объект с обработчиками
const handlers = {
    api: function (request, response) {
        response.writeHead(200, { "Content-Type": "application/json" });
        response.end(JSON.stringify({ message: "Данные с API" }));
    },
    notFound: function (request, response) {
        response.writeHead(404, { "Content-Type": "text/plain" });
        response.end("404 Страница не найдена");
    },
};

server.listen(3000, () => {
    console.log("Сервер запущен на http://localhost:3000");
});
```

### Применение middleware для расширения функциональности сервера

#### Что такое Middleware?

Middleware (промежуточное ПО) в контексте веб-серверов Node.js - это функции, которые имеют доступ к объектам запроса (request), ответа (response) и следующей функции в цикле запрос-ответ приложения. Middleware может выполнять различные задачи: обработка данных запроса, выполнение проверок безопасности, логирование и многое другое.

#### Основные Принципы Работы с Middleware

1. **Последовательная Обработка:**
   Middleware обрабатывается последовательно, в том порядке, в котором они были добавлены.
2. **Доступ к Request и Response:**
   Каждая функция Middleware имеет доступ к объектам запроса и ответа, а также к следующей функции Middleware в стеке.
3. **Прерывание Цикла или Передача Управления:**
   Middleware может завершить цикл запроса, отправив ответ, или передать управление следующей функции, вызвав `next()`.

#### Реализация Простого Middleware

Давайте рассмотрим, как создать и использовать простой Middleware в Node.js без использования сторонних фреймворков, таких как Express.

```javascript
const http = require("http");

// Пример Middleware для логирования
function logRequest(req, res, next) {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
    next(); // Передаем управление следующему обработчику
}

// Функция, которая создает сервер и применяет Middleware
function applyMiddleware(middleware, serverHandler) {
    return (req, res) => {
        function next() {
            serverHandler(req, res);
        }
        middleware(req, res, next);
    };
}

// Основная логика сервера
function serverHandler(req, res) {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("Привет, мир!");
}

const server = http.createServer(applyMiddleware(logRequest, serverHandler));

server.listen(3000, () => {
    console.log("Сервер запущен на http://localhost:3000");
});
```

В этом примере функция `logRequest` является Middleware, которая логирует запросы, а `applyMiddleware` применяет этот Middleware к основной логике сервера.

#### Продвинутое Использование Middleware

1. **Цепочки Middleware:**
   Можно создать несколько Middleware и применить их последовательно. Каждая функция Middleware может выполнять свою задачу и затем вызывать `next()` для передачи управления следующему Middleware.
2. **Обработка Ошибок:**
   Middleware может быть использовано для централизованной обработки ошибок, путем перехвата исключений и отправки соответствующих ответов клиенту.
3. **Аутентификация и Авторизация:**
   Используйте Middleware для проверки пользовательских данных на всех или на определенных маршрутах вашего приложения.
4. **Логирование и Мониторинг:**
   Регистрация действий пользователей, времени обработки запросов и других важных метрик.
