# Введение в базы данных и практика с PostgreSQL

## Теория баз данных

### История и этапы развития баз данных.

#### Ранние годы (1950-е - 1960-е)

-   **Появление файловых систем**: В ранние годы компьютерной эры, данные хранились в простых файловых системах. Эти системы были неэффективными, так как каждое приложение требовало создания собственной системы для управления данными.
-   **Иерархические и сетевые модели**: С развитием технологий появились иерархические (например, IBM IMS) и сетевые модели данных (например, CODASYL DBTG). Эти модели позволяли более эффективно организовывать и извлекать данные, но были сложными в управлении и не гибкими.

#### Развитие реляционных баз данных (1970-е)

-   **Теория реляционных баз данных**: Эдгар Кодд, сотрудник IBM, представил концепцию реляционных баз данных в 1970 году. Его статья "A Relational Model of Data for Large Shared Data Banks" заложила основы для реляционных СУБД.
-   **SQL и первые СУБД**: В 1970-х годах был разработан SQL (Structured Query Language), язык запросов для управления реляционными данными. Появились первые коммерческие реляционные СУБД, такие как Oracle.

#### Расцвет реляционных СУБД (1980-е - 1990-е)

-   **Рост популярности и стандартизация**: Реляционные СУБД стали более популярными благодаря их гибкости, мощности и удобству использования. Появилась стандартизация SQL, что способствовало росту и совместимости решений.
-   **Развитие технологий**: Были внедрены такие технологии, как ACID (Atomicity, Consistency, Isolation, Durability) для транзакций, а также новые методы индексации и хранения данных.

#### Появление объектно-ориентированных и NoSQL баз данных (2000-е)

-   **Объектно-ориентированные СУБД**: В ответ на сложность работы с объектно-ориентированными языками программирования и реляционными базами данных, были разработаны объектно-ориентированные СУБД.
-   **Рост NoSQL**: С расширением Интернета и возникновением больших данных появилась потребность в более гибких системах управления базами данных. Это привело к развитию NoSQL баз данных, таких как MongoDB, которые предлагают масштабируемость и гибкость для работы с большими объемами неструктурированных данных.

#### Современные тенденции (2010-е и далее)

-   **Большие данные и распределенные системы**: Развитие технологий больших данных привело к появлению распределенных систем управления базами данных, способных обрабатывать огромные объемы данных.
-   **Облачные базы данных**: Облачные технологии стали интегрироваться в системы управления базами данных, предоставляя гибкость, масштабируемость и доступность данных на глобальном уровне.
-   **Искусственный интеллект и машинное обучение**: Интеграция ИИ и машинного обучения с базами данных открывает новые возможности для анализа и использования данных.

### Основные понятия баз данных и систем управления базами данных.

#### База данных (БД)

-   **Определение**: База данных — это организованная коллекция структурированных данных, хранящихся электронно в компьютерной системе. Базы данных позволяют эффективно хранить, изменять и извлекать информацию.
-   **Типы данных**: Включает различные типы данных, такие как текст, числа, даты и многие другие.
-   **Структура**: Данные обычно организуются в таблицы, которые состоят из строк и столбцов. Столбцы представляют типы данных, а строки — конкретные записи.

#### Система управления базами данных (СУБД)

-   **Определение**: СУБД — это программное обеспечение, предназначенное для создания, управления и манипулирования базами данных. СУБД обеспечивает эффективный доступ к данным и их безопасность.
-   **Функции СУБД**: Включают хранение данных, выполнение запросов, обновление данных, управление транзакциями, обеспечение безопасности и резервное копирование.
-   **Примеры СУБД**: PostgreSQL, MySQL, Oracle, Microsoft SQL Server, MongoDB.

#### Модели данных

-   **Реляционная модель**: Использует таблицы (отношения) для представления данных и их взаимосвязей. Данные в таблицах связаны через ключи.
-   **Объектно-ориентированная модель**: Представляет данные в виде объектов, подобно объектам в объектно-ориентированном программировании.
-   **Документо-ориентированная модель (NoSQL)**: Ориентирована на хранение документов, часто используется в системах, где данные имеют неструктурированный или полуструктурированный формат.

#### Транзакции

-   **Определение**: Транзакция в контексте баз данных — это последовательность операций, которые выполняются как единое целое. Транзакции обеспечивают целостность данных.
-   **Свойства (ACID)**: Атомарность, Согласованность, Изолированность, Долговечность.

#### SQL (Structured Query Language)

-   **Определение**: SQL — это язык программирования, используемый для управления данными в реляционной СУБД.
-   **Основные операции**: Включают SELECT (извлечение данных), INSERT (вставка новых данных), UPDATE (обновление существующих данных), DELETE (удаление данных).

#### Нормализация

-   **Цель**: Нормализация — это процесс организации данных в базе данных для уменьшения избыточности и улучшения целостности.
-   **Нормальные формы**: Существует несколько нормальных форм, каждая из которых устраняет определенные типы избыточности и зависимостей.

#### Индексы

-   **Определение**: Индекс в базе данных — это структура данных, которая улучшает скорость операций поиска/выборки данных.
-   **Применение**: Индексы важны для улучшения производительности в больших базах данных.

### Обзор различных моделей баз данных: файловая, сетевая, иерархическая, реляционная, объектно-ориентированная.

#### Файловая модель

-   **Описание**: В файловой модели данные хранятся в файлах, обычно текстовых, где каждая строка представляет одну запись, а поля разделены определенными символами (например, запятой в CSV-файлах).
-   **Преимущества**: Простота и понятность, легкость в реализации.
-   **Недостатки**: Отсутствие механизмов для обработки связанных данных, сложности с обновлением, масштабируемостью и целостностью данных.

#### Сетевая модель

-   **Описание**: В сетевой модели данные представлены в виде коллекции записей, связанных между собой сетью связей. Это более гибкая альтернатива иерархической модели.
-   **Преимущества**: Поддержка множественных связей между записями, большая гибкость в сравнении с иерархической моделью.
-   **Недостатки**: Сложность в управлении и навигации, сложные запросы и обновления.

#### Иерархическая модель

-   **Описание**: Данные организованы в структуру, напоминающую дерево, где каждая запись имеет одного родителя и ноль или более детей. Пример — система управления базами данных IBM IMS.
-   **Преимущества**: Простота и высокая производительность для иерархически организованных данных.
-   **Недостатки**: Ограниченная гибкость, сложности при изменении структуры, проблемы с представлением множественных отношений.

#### Реляционная модель

-   **Описание**: Основана на представлении данных в виде таблиц (отношений), где каждая строка — это запись, а столбцы — атрибуты. SQL обычно используется для запросов к таким базам данных.
-   **Преимущества**: Гибкость и мощность в запросах, поддержка нормализации, широкое распространение и поддержка.
-   **Недостатки**: Может быть неэффективна для некоторых типов неструктурированных данных, ограничения производительности при очень больших объемах данных.

#### Объектно-ориентированная модель

-   **Описание**: Данные представлены в форме объектов, как в объектно-ориентированном программировании. Эти базы данных могут хранить сложные типы данных и их взаимосвязи.
-   **Преимущества**: Гибкость в моделировании и хранении сложных структур, поддержка наследования и полиморфизма.
-   **Недостатки**: Сложность и потенциально высокая стоимость, может потребоваться специализированный язык запросов.

Каждая из этих моделей имеет свои особенности, преимущества и области применения. Выбор модели зависит от конкретных требований к системе и характеристик данных.

## Язык SQL

### Почему SQL?

SQL – Structured Query Language (язык структурированных запросов).

Давным-давно до 86-х годов языка SQL не было, но реляционные базы данных были, реляционными они называются, потому что пошли от английского слова relation - связь. И почти у каждой компании была своя самописная база данных у которой был свой язык взаимодействия и в один прекрасный момент разработчики собрались и сказали, довольно! И сделали стандарт для взаимодействия с реляционными базами данных который и назвали SQL в 1983 году Международная организация по стандартизации (ISO) и Американский национальный институт стандартов (ANSI) начали разработку этого языка и закончили в 1986.

И теперь практически не важно какая именно база будет в компании, PostgreSQL, MySql, Oracle, SQLite основная суть остается неизменной, сделать запросы и записать данные в базу вы точно сможете, так как это язык.

### Структура языка

Все операторы SQL делятся на 3 группы.

-   DDL (Data Definition Language) – Операторы определения данных. Операторы, которые объясняют как создать или изменить структуру данных
-   DML (Data Manipulation Language) – Операторы манипуляции данными. Взаимодействия с базой данных, что мы хотим взять, положить и прочее
-   DCL (Data Control Language) – Операторы определения доступа к данным. Управление правами доступа.

Язык SQL совершенно регистра независимый. Но принято писать команды заглавными буквами (верхний регистр).

Мы разберем их по отдельности по курсу, пока я опишу, что входит в эти группы.

### Операторы определения данных (DDL)

Нужны для:

-   CREATE DATABASE - Создание базы данных
-   DROP DATABASE - Удаления базы данных
-   CREATE TABLE - Создание таблицы
-   DROP TABLE - Удаление таблицы
-   ALTER DATABASE Модификация базы
-   ALTER TABLE Модификация таблицы

Как мы видим основные операторы это CREATE, DROP и ALTER

### Операторы манипуляции данными (DML)

Это вездесущие операторы с которыми вы будете чаще всего работать:

-   SELECT - Получить данные из таблицы
-   UPDATE - Обновить данные в таблице
-   INSERT - Добавить данные в таблицу
-   DELETE - Удалить данные из таблицы

### Операторы определения доступа к данным (DCL)

Управление правами доступа, как к пользователю так и к таблице, так же транзакции тоже считаются контролем данных.

-   GRANT - права пользователей
-   CONNECT - соединение с сервером
-   LOCK TABLE - блокировка таблицы
-   UNLOCK TABLE - разблокировать таблицу
-   COMMIT - так же как и в git добавить изменения
-   ROLLBACK - отменить изменения в транзакции (если не было COMMIT)

### Синтаксис

Как я писал выше все команды заглавными буквами.

Разделитель для запроса это точка с запятой ";"

Вот какие бывают комментарии:

-   "--" два минуса - это однострочный комментарий, стандартный, который железно работает во всех базах
-   "#" - тоже комментарий
-   "/\*\*/" - многострочный комментарий.

Пример запроса:

![Simple Query](https://textbook.edu.goit.global/mysql-qhg4na/v1/assets/images/simple_query-0b15ad31075e164d676e7402ed5d5a0c.png)

Что я сделал, написал комментарий "-- I wanna get 2", он никак не отработал, это понятно из того, что ошибок нет, а потом сделал запрос "SELECT 1 + 1;". Результат выполнения SQL всегда таблица, колонка называется 1 + 1, а ее значение 2.

## Практика с PostgreSQL через Node.js

### Установка и настройка PostgreSQL.

#### Установка на Windows

1. **Скачивание**: Перейдите на официальный сайт PostgreSQL (https://www.postgresql.org/) и скачайте последнюю версию для Windows.
2. **Установка**: Запустите скачанный установочный файл и следуйте инструкциям мастера установки. Выберите компоненты для установки (обычно сервер баз данных, pgAdmin - инструмент управления, командная оболочка).
3. **Настройка**: В процессе установки вам будет предложено задать пароль для пользователя `postgres`. Запомните или запишите его, он будет нужен для доступа к базе данных.
4. **Завершение установки**: После завершения установки PostgreSQL будет запущен как служба Windows.

#### Установка на macOS

1. **Скачивание**: Можно использовать Homebrew для установки PostgreSQL: в терминале выполните команду `brew install postgresql`.
2. **Инициализация базы данных**: После установки инициализируйте базу данных с помощью команды `initdb /usr/local/var/postgres`.
3. **Запуск PostgreSQL**: Используйте команду `brew services start postgresql` для запуска PostgreSQL.
4. **Создание нового пользователя**: (опционально) Вы можете создать нового пользователя для управления базами данных.

#### Установка на Linux (Debian/Ubuntu)

1. **Установка**: Откройте терминал и выполните команды:

    ```
    sudo apt update
    sudo apt install postgresql postgresql-contrib
    ```

2. **Запуск службы**: PostgreSQL должен запуститься автоматически. Проверьте статус службы командой `sudo service postgresql status`.
3. **Настройка**: По умолчанию создаётся пользователь `postgres`. Чтобы начать использовать PostgreSQL, переключитесь на этого пользователя командой `sudo -i -u postgres`.

#### Общие шаги после установки

1. **Создание новой базы данных**:

    - Войдите в командную оболочку PostgreSQL, выполнив `psql`.
    - Создайте базу данных командой `CREATE DATABASE имя_базы;`.

2. **Установка pgAdmin** (для Windows и macOS обычно устанавливается вместе с PostgreSQL):

    - pgAdmin — это популярный инструмент управления и разработки для PostgreSQL.
    - Зайдите на сайт pgAdmin (https://www.pgadmin.org/) и скачайте подходящую версию.

3. **Настройка подключения**:

    - В pgAdmin создайте новое подключение, указав необходимые данные: имя хоста (обычно localhost), номер порта (по умолчанию 5432), имя пользователя и пароль.

4. **Дополнительные настройки**:

    - Можно настроить конфигурационные файлы PostgreSQL (`postgresql.conf` и `pg_hba.conf`) для тонкой настройки работы сервера, безопасности и доступа к базам данных.

Это базовые шаги для начала работы с PostgreSQL. После установки и настройки вы сможете создавать и управлять базами данных, используя SQL-запросы или инструменты управления, такие как pgAdmin.

### Настройка проекта для работы с PostgreSQL.

Для подробной настройки проекта Node.js для работы с PostgreSQL вам необходимо выполнить следующие шаги:

#### **Настройка среды Node.js**:

-   Убедитесь, что Node.js установлен в вашей системе. Если нет, скачайте и установите его с официального сайта [Node.js](https://nodejs.org/).
-   Создайте новую директорию для вашего проекта и инициализируйте новый проект Node.js, используя команду `npm init` в терминале. Это создаст файл `package.json`, который будет управлять зависимостями вашего проекта.

#### **Установка библиотеки для работы с PostgreSQL**:

-   Для взаимодействия с базой данных PostgreSQL используется пакет `pg`. Установите его, запустив `npm install pg` в терминале вашего проекта.
-   Эта библиотека предоставляет набор функций для подключения к PostgreSQL и выполнения SQL-запросов.

#### **Настройка подключения к базе данных**:

-   Создайте файл (например, `database.js`) для настройки подключения к базе данных.
-   Импортируйте модуль `pg` и создайте объект `Pool` или `Client`, который будет использоваться для подключения к базе данных. Например:

    ```javascript
    const { Pool } = require("pg");

    const pool = new Pool({
        user: "username", // ваше имя пользователя
        host: "localhost",
        database: "mydatabase", // название вашей базы данных
        password: "password", // ваш пароль
        port: 5432,
    });

    module.exports = pool;
    ```

#### **Работа с базой данных в вашем приложении**:

-   В основном файле вашего приложения (например, `app.js`) импортируйте настроенный объект подключения.
-   Используйте этот объект для выполнения SQL-запросов. Например, для выполнения запроса SELECT:

    ```javascript
    const pool = require("./database");

    pool.query("SELECT * FROM your_table", (err, res) => {
        if (err) throw err;
        for (let row of res.rows) {
            console.log(row);
        }
        pool.end();
    });
    ```

### Создание таблиц: первичный ключ, уникальность, значения по умолчанию.

#### Чтобы создать новую таблицу в pgAdmin и просмотреть её, вы можете следовать этим шагам:

1. **Откройте pgAdmin** и подключитесь к серверу, на котором у вас установлен PostgreSQL.
2. **Раскройте дерево сервера**. На левой панели вы увидите иерархию, которая начинается с вашего сервера (в вашем случае это "Server"), затем идет "PostgreSQL", и под ним список баз данных, таких как "postgres" и "test".
3. **Выберите базу данных**, в которой вы хотите создать таблицу. Например, если вы хотите работать с базой данных "test", щёлкните по ней.
4. **Раскройте список "Schemas"** (схем) внутри вашей базы данных. Обычно используется схема "public", если вы не создавали специальные схемы.
5. **Выберите схему "public"** и раскройте её. Там вы увидите папки, такие как "Tables", "Views", "Functions" и другие.
6. **Щёлкните правой кнопкой мыши по папке "Tables"** и выберите "Create" -> "Table...".
7. **В открывшемся окне** введите имя вашей новой таблицы и определите её структуру. Вы можете добавить столбцы, указав их имена, типы данных и другие параметры (например, если столбец является первичным ключом, можно установить галочку "Primary Key").
8. **После того как вы настроите структуру таблицы**, нажмите "Save" в окне создания таблицы.
9. **Теперь вы можете просмотреть созданную таблицу**, раскрыв папку "Tables" в схеме "public" вашей базы данных. Ваша новая таблица должна отображаться там.
10. **Для просмотра содержимого таблицы** дважды щёлкните по ней. Откроется новая вкладка, где можно выполнить запросы SQL или просмотреть данные, если они уже есть в таблице.

#### Первичный ключ (Primary Key)

Первичный ключ — это уникальный идентификатор каждой записи в таблице. Он гарантирует уникальность каждой строки и не может быть `NULL`.

1. **Определение при создании таблицы**:

    - Создайте таблицу и определите один из столбцов как первичный ключ. Например, для создания таблицы `users` с первичным ключом `id`:

        ```sql
        CREATE TABLE users (
          id SERIAL PRIMARY KEY,
          username VARCHAR(50),
          email VARCHAR(100)
        );
        ```

    - Здесь `SERIAL` автоматически генерирует уникальные числовые значения для `id`.

2. **Добавление первичного ключа после создания таблицы**:

    - Если таблица уже создана, вы можете добавить первичный ключ с помощью `ALTER TABLE`:

        ```sql
        ALTER TABLE users ADD PRIMARY KEY (id);
        ```

#### Уникальность (Unique Constraint)

Уникальное ограничение (`UNIQUE`) гарантирует, что все значения в столбце или их комбинации уникальны в пределах таблицы.

1. **Определение при создании таблицы**:

    - Определите уникальный столбец во время создания таблицы. Например, чтобы сделать email уникальным:

        ```sql
        CREATE TABLE users (
          id SERIAL PRIMARY KEY,
          username VARCHAR(50),
          email VARCHAR(100) UNIQUE
        );
        ```

2. **Добавление уникального ограничения после создания таблицы**:

    - Используйте `ALTER TABLE` для добавления уникального ограничения:

        ```sql
        ALTER TABLE users ADD UNIQUE (email);
        ```

#### Значения по умолчанию (Default Values)

Значения по умолчанию используются для автоматического заполнения столбца, если при вставке строки значение не указано.

1. **Определение при создании таблицы**:

    - Укажите значение по умолчанию при создании таблицы. Например, установите значение по умолчанию для столбца `created_at`:

        ```sql
        CREATE TABLE users (
          id SERIAL PRIMARY KEY,
          username VARCHAR(50),
          email VARCHAR(100) UNIQUE,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        ```

    - `CURRENT_TIMESTAMP` автоматически устанавливает текущую дату и время при создании записи.

2. **Установка значения по умолчанию после создания таблицы**:

    - Используйте `ALTER TABLE` для установки значения по умолчанию:

        ```sql
        ALTER TABLE users ALTER COLUMN created_at SET DEFAULT CURRENT_TIMESTAMP;
        ```

Эти примеры демонстрируют базовые принципы создания таблиц с использованием первичных ключей, уникальных ограничений и значений по умолчанию в SQL. Обратите внимание, что реальная синтаксис и возможности могут немного отличаться в зависимости от используемой системы управления базами данных (например, MySQL, PostgreSQL, SQL Server и т.д.).

#### Давайте рассмотрим реальный пример создания таблицы в PostgreSQL.

-   `id`: первичный ключ, автоматически увеличивается.
-   `name`: имя сотрудника, строка.
-   `email`: электронная почта сотрудника, уникальное значение.
-   `date_joined`: дата присоединения сотрудника, со значением по умолчанию - текущая дата и время.

Для начала убедитесь, что у вас установлены Node.js и npm. Затем выполните следующие шаги:

1. **Создайте новый проект Node.js**:

    - Откройте терминал и выполните следующие команды:
        ```bash
        mkdir myproject
        cd myproject
        pnpm init -y
        ```

2. **Установите пакет `pg`**:

    - В терминале выполните:
        ```bash
        pnpm install pg
        ```

3. **Создайте файл для работы с базой данных** (например, `database.js`):

    - В этом файле установите подключение к вашей базе данных PostgreSQL:

        ```javascript
        const { Pool } = require("pg");

        const pool = new Pool({
            connectionString:
                "postgresql://postgres:290501@localhost:5432/test",
        });

        module.exports = pool;
        ```

4. **Создайте таблицу `employees`**:

    - Создайте новый файл, например `createTable.js`, и в нём напишите скрипт для создания таблицы:

        ```javascript
        const pool = require("./database");

        const createTable = async () => {
            const queryText = `
            CREATE TABLE IF NOT EXISTS employees (
              id SERIAL PRIMARY KEY,
              name VARCHAR(100),
              email VARCHAR(100) UNIQUE,
              date_joined TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
          `;

            try {
                await pool.query(queryText);
                console.log("Table 'employees' created successfully");
                pool.end();
            } catch (error) {
                console.error(error);
            }
        };

        createTable();
        ```

5. **Запустите скрипт**:

    - В терминале выполните команду:
        ```bash
        node createTable.js
        ```

### Основы типов данных и индексов.

#### Основы Типов Данных в PostgreSQL

В PostgreSQL, как и в большинстве систем управления базами данных, имеется множество типов данных, позволяющих определить характеристики данных, которые могут быть сохранены в каждом столбце таблицы. Вот некоторые из основных типов данных:

1. **Числовые типы данных**:

    - `INTEGER`: Целое число (4 байта).
    - `BIGINT`: Большое целое число (8 байт).
    - `SERIAL`: Автоинкрементное целое число (4 байта).
    - `REAL` и `DOUBLE PRECISION`: Вещественные числа с плавающей запятой.
    - `NUMERIC` или `DECIMAL`: Числа с фиксированной точностью.

2. **Строковые типы данных**:

    - `CHAR(n)`: Строка фиксированной длины.
    - `VARCHAR(n)`: Строка переменной длины с максимальным ограничением.
    - `TEXT`: Строка переменной длины без ограничения длины.

3. **Логический тип данных**:

    - `BOOLEAN`: Логическое значение (`true` или `false`).

4. **Дата и время**:

    - `DATE`: Дата без времени суток.
    - `TIME`: Время суток без даты.
    - `TIMESTAMP`: Дата и время суток.
    - `TIMESTAMP WITH TIME ZONE`: Дата и время суток с часовым поясом.

5. **Другие типы данных**:

    - `ARRAY`: Массив значений.
    - `JSON` или `JSONB`: JSON-данные.
    - `UUID`: Универсальный уникальный идентификатор.
    - `BYTEA`: Бинарные данные.

#### Индексы в PostgreSQL

Индексы в базах данных используются для ускорения процесса поиска данных. В PostgreSQL индексы можно создавать для одного или нескольких столбцов таблицы, чтобы ускорить выборку данных на основе этих столбцов.

1. **Создание индекса**:

    - Для создания индекса используется команда `CREATE INDEX`. Например, для создания индекса для столбца `email` в таблице `users`:
        ```sql
        CREATE INDEX idx_email ON users(email);
        ```

2. **Типы индексов**:

    - **B-Tree**: По умолчанию используется для сортировки данных в определенном порядке. Это хороший общий выбор для индексации.
    - **Hash**: Подходит для операций равенства.
    - **GiST** и **GIN**: Используются для индексирования сложных типов данных, таких как массивы, текстовый поиск и геометрические типы.

3. **Работа с индексами**:

    - Индексы автоматически используются PostgreSQL для ускорения запросов `SELECT`, `UPDATE`, `DELETE`, где есть условия фильтрации или сортировки по индексированным столбцам.
    - Однако индексы увеличивают время выполнения операций вставки или обновления данных, так как индекс также должен быть обновлен.

4. **Управление индексами**:

    - Для удаления индекса используется команда `DROP INDEX`.
    - Можно также использовать `EXPLAIN` для анализа запросов и определения, используется ли индекс эффективно.

#### Расширение Существующей Таблицы

Добавим следующие поля в таблицу `employees`:

-   `department`: Отдел, в котором работает сотрудник, строка до 50 символов.
-   `salary`: Зарплата сотрудника, числовой тип с 2 знаками после запятой.
-   `is_full_time`: Является ли сотрудник полноценным сотрудником компании, логический тип данных.

##### Модификация Таблицы и Добавление Индексов

1. **Создайте скрипт для модификации таблицы**:

    Создайте файл `modifyTable.js` и добавьте в него следующий код:

    ```javascript
    const pool = require("./database");

    const modifyTable = async () => {
        const queryAlterTable = `
        ALTER TABLE employees
        ADD COLUMN department VARCHAR(50),
        ADD COLUMN salary NUMERIC(10, 2),
        ADD COLUMN is_full_time BOOLEAN DEFAULT true;
      `;

        const queryCreateIndex = `
        CREATE INDEX idx_department ON employees(department);
      `;

        try {
            await pool.query(queryAlterTable);
            console.log("Table 'employees' modified successfully");

            await pool.query(queryCreateIndex);
            console.log("Index on 'department' created successfully");

            pool.end();
        } catch (error) {
            console.error(error);
        }
    };

    modifyTable();
    ```

    В этом скрипте:

    - Мы модифицируем таблицу `employees`, добавляя новые столбцы.
    - Создаём индекс `idx_department` для столбца `department`.

2. **Запустите скрипт**:

    В терминале выполните команду:

    ```bash
    node modifyTable.js
    ```

Этот скрипт модифицирует существующую таблицу `employees`, добавляя новые столбцы и создавая индекс для поля `department`. Создание индекса улучшит производительность запросов, которые фильтруют или сортируют данные по отделу сотрудника.

### Практика выполнения запросов SELECT, INSERT, UPDATE, DELETE через Node.js.

Давайте рассмотрим, как выполнять базовые операции с базой данных PostgreSQL — SELECT, INSERT, UPDATE и DELETE — используя Node.js и пакет `pg`. Мы будем использовать таблицу `employees`, созданную в предыдущих примерах.

#### Выполнение Запросов

1. **SELECT - Извлечение данных**

    Создайте файл `select.js` и добавьте в него следующий код:

    ```javascript
    const pool = require("./database");

    const selectEmployees = async () => {
        try {
            const result = await pool.query("SELECT * FROM employees");
            console.log(result.rows);
        } catch (error) {
            console.error(error);
        } finally {
            pool.end();
        }
    };

    selectEmployees();
    ```

    Этот скрипт извлекает все записи из таблицы `employees` и выводит их в консоль.

2. **INSERT - Добавление данных**

    Создайте файл `insert.js` и добавьте в него следующий код:

    ```javascript
    const pool = require("./database");

    const insertEmployee = async () => {
        const query = `
        INSERT INTO employees (name, email, department, salary, is_full_time) 
        VALUES ('John Doe', 'johndoe@example.com', 'IT', 75000, true)
      `;

        try {
            await pool.query(query);
            console.log("Employee added successfully");
        } catch (error) {
            console.error(error);
        } finally {
            pool.end();
        }
    };

    insertEmployee();
    ```

    Этот скрипт добавляет нового сотрудника в таблицу `employees`.

3. **UPDATE - Обновление данных**

    Создайте файл `update.js` и добавьте в него следующий код:

    ```javascript
    const pool = require("./database");

    const updateEmployee = async () => {
        const query = `
        UPDATE employees
        SET salary = 80000
        WHERE name = 'John Doe'
      `;

        try {
            await pool.query(query);
            console.log("Employee updated successfully");
        } catch (error) {
            console.error(error);
        } finally {
            pool.end();
        }
    };

    updateEmployee();
    ```

    Этот скрипт обновляет зарплату сотрудника по имени `John Doe`.

4. **DELETE - Удаление данных**

    Создайте файл `delete.js` и добавьте в него следующий код:

    ```javascript
    const pool = require("./database");

    const deleteEmployee = async () => {
        const query = `
        DELETE FROM employees
        WHERE name = 'John Doe'
      `;

        try {
            await pool.query(query);
            console.log("Employee deleted successfully");
        } catch (error) {
            console.error(error);
        } finally {
            pool.end();
        }
    };

    deleteEmployee();
    ```

    Этот скрипт удаляет запись сотрудника по имени `John Doe`.

Для управления записями в PostgreSQL через Node.js без использования Express.js, можно использовать встроенный в Node.js модуль `http` для создания простого HTTP сервера. Вот пример, как это можно сделать:

### Шаг 1: Настройка и Установка

1. **Инициализируйте новый проект Node.js**:

    ```bash
    mkdir my-postgres-project
    cd my-postgres-project
    npm init -y
    ```

2. **Установите пакет `pg`**:

    ```bash
    npm install pg
    ```

### Шаг 2: Настройка PostgreSQL

Убедитесь, что у вас есть PostgreSQL база данных и таблица `employees` с полями `id`, `name`, `email`, `department`, `salary`.

### Шаг 3: Создание HTTP Сервера

1. **Создайте файл `server.js`**:

    ```javascript
    const http = require("http");
    const { Pool } = require("pg");
    const url = require("url");

    const pool = new Pool({
        user: "your_username",
        host: "localhost",
        database: "your_database",
        password: "your_password",
        port: 5432,
    });

    const server = http.createServer(async (req, res) => {
        const reqUrl = url.parse(req.url, true);

        // Обработка GET запроса
        if (reqUrl.pathname == "/employees" && req.method === "GET") {
            try {
                const result = await pool.query("SELECT * FROM employees");
                res.writeHead(200, { "Content-Type": "application/json" });
                res.end(JSON.stringify(result.rows));
            } catch (error) {
                res.writeHead(500);
                res.end(JSON.stringify({ error: error.message }));
            }
        }

        // Для POST, PUT, DELETE запросов добавьте здесь аналогичный код
    });

    server.listen(3000, () => {
        console.log(`Server running on http://localhost:3000/`);
    });
    ```

### Шаг 4: Запуск Сервера

Запустите сервер командой:

```bash
node server.js
```

### Тестирование через Postman

Теперь вы можете тестировать ваш API через Postman, отправляя запросы на `http://localhost:3000/employees`.

### Примечания

-   В этом примере представлен только обработчик для GET запроса. Для поддержки POST, PUT и DELETE запросов вам нужно добавить дополнительный код для чтения тела запроса и выполнения соответствующих SQL команд.
-   Важно правильно управлять подключениями к базе данных, закрывая их после завершения запроса.
-   Этот подход является более низкоуровневым по сравнению с использованием Express.js и может потребовать дополнительной обработки ошибок и управления запросами.
