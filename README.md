# 5.3 MongoDB и Нормализация

## Введение в MongoDB

### Введение

#### Введение в MongoDB

MongoDB — это мощная, гибкая и масштабируемая база данных NoSQL, которая хранит данные в формате, похожем на JSON, называемом BSON (Binary JSON). В отличие от традиционных реляционных баз данных, которые используют таблицы и строки, MongoDB работает с коллекциями и документами, что делает её идеальной для хранения сложных иерархических данных и обработки больших объёмов данных с высокой производительностью и гибкостью.

#### История и популярность

MongoDB была разработана компанией MongoDB Inc. и впервые выпущена в 2009 году. Она быстро приобрела популярность среди разработчиков благодаря своей простоте использования, гибкости структуры данных, масштабируемости и мощным возможностям запросов. MongoDB используется широким кругом организаций, от стартапов до крупных корпораций, для различных приложений, включая веб-сайты, бизнес-аналитику, социальные сети, Интернет вещей (IoT) и многое другое.

#### Особенности MongoDB

-   **Гибкость структуры данных:** MongoDB позволяет хранить документы, которые могут содержать различные типы и структуры данных без необходимости предварительного определения схемы данных. Это делает MongoDB идеальной для приложений, где структура данных может меняться со временем.
-   **Масштабируемость:** MongoDB предлагает горизонтальное масштабирование с помощью шардинга, позволяя распределять данные по нескольким серверам для улучшения производительности и устойчивости.
-   **Высокая производительность:** MongoDB оптимизирована для быстрых операций чтения и записи и поддерживает индексацию полей в документах для ускорения поиска данных.
-   **Мощные возможности запросов:** MongoDB предлагает богатый набор операций для работы с данными, включая агрегацию, текстовый поиск и геопространственные запросы.

#### Применение MongoDB

MongoDB широко используется в различных типах приложений благодаря своей универсальности и производительности. Она особенно хорошо подходит для приложений, требующих быстрого развития и гибкости в управлении данными, таких как:

-   Веб-приложения и сервисы
-   Мобильные приложения
-   Социальные сети
-   Платформы для работы с большими данными и аналитикой
-   Приложения для Интернета вещей (IoT)

### Краткий обзор NoSQL баз данных. Чем MongoDB отличается от традиционных реляционных баз данных.

#### Краткий обзор NoSQL баз данных

NoSQL (Not Only SQL) базы данных — это широкий класс систем управления базами данных, которые отличаются от традиционных реляционных баз данных (RDBMS) своей гибкостью структур, способами хранения данных и механизмами обработки запросов. Они разработаны для обеспечения высокой масштабируемости, производительности и гибкости в управлении данными. NoSQL базы данных подразделяются на несколько типов, включая документо-ориентированные, колоночные, ключ-значение и графовые базы данных. Каждый тип оптимизирован под определённые виды задач и объёмы данных.

#### Отличия MongoDB от традиционных реляционных баз данных

-   **Гибкость структуры данных:** В отличие от реляционных баз данных, где структура данных (схема) должна быть строго определена до начала работы с данными, MongoDB и другие NoSQL базы данных предлагают гибкость структур. MongoDB хранит данные в документах, что позволяет каждому документу иметь свою уникальную структуру без необходимости следования жёстко заданной схеме.
-   **Масштабируемость:** Традиционные реляционные базы данных часто опираются на вертикальное масштабирование (усиление мощности одного сервера), что может быть дорого и имеет свои пределы. MongoDB и другие NoSQL системы обеспечивают горизонтальное масштабирование (распределение данных по множеству серверов), что может быть более эффективным и экономичным способом управления большими объёмами данных.
-   **Производительность:** Для определённых типов приложений и операций MongoDB может предложить лучшую производительность благодаря своей способности оптимизировать работу с документами и отсутствию необходимости присоединения таблиц, что является типичным для реляционных баз данных.
-   **Типы запросов:** MongoDB поддерживает богатый язык запросов, включая поиск по тексту, агрегацию данных и геопространственные запросы, что может быть не так легко реализуемо в некоторых реляционных системах без использования дополнительных расширений или инструментов.
-   **Денормализация данных:** В реляционных базах данных данные часто нормализуются для устранения дублирования и обеспечения целостности данных, что может привести к необходимости выполнения множественных запросов (JOIN операции) для получения связанных данных. MongoDB позволяет денормализовать данные, храня сложные структуры в одном документе, что упрощает запросы и может улучшить производительность.
-   **Транзакции:** Хотя традиционные реляционные базы данных давно поддерживают транзакции, MongoDB добавила поддержку мультидокументных транзакций только начиная с версии 4.0, приближая свои возможности к реляционным системам в этом аспекте.

### Основные концепции MongoDB

#### Различия между SQL и NoSQL запросами.

Для более глубокого понимания MongoDB, давайте подробно рассмотрим её основные концепции. MongoDB является документо-ориентированной базой данных NoSQL, что означает, что вместо хранения данных в таблицах, как в традиционных реляционных базах данных, она использует документы и коллекции. Эти основные элементы, вместе с другими ключевыми аспектами, формируют фундамент работы с MongoDB.

#### Документы и Коллекции

-   **Документы:** Основная единица данных в MongoDB. Документы хранятся в формате BSON (Binary JSON), который является бинарным представлением данных в формате JSON. Это позволяет MongoDB хранить сложные структуры в виде вложенных документов и массивов. Документ может содержать разные типы данных, такие как текст, числа, массивы, булевы значения, даты и даже другие документы. Это обеспечивает гибкость при моделировании данных.
-   **Коллекции:** Группа документов в MongoDB. Коллекция аналогична таблице в реляционных базах данных, но в отличие от таблиц, не требует определения схемы данных. Документы в одной коллекции могут иметь различную структуру, хотя обычно они следуют общему "формату" для удобства работы.

#### \_id и BSON

-   **\_id:** Каждый документ в MongoDB автоматически получает уникальный идентификатор, `_id`, который используется для обеспечения уникальности каждого документа в коллекции. Этот идентификатор можно задать вручную при создании документа, но если он не указан, MongoDB сгенерирует его автоматически в форме ObjectId. ObjectId представляет собой 12-байтовое значение, гарантирующее уникальность документов.
-   **BSON:** Формат хранения данных, используемый MongoDB. BSON расширяет формат JSON, добавляя дополнительные типы данных, такие как `date` и `binary data`, что делает его более подходящим для работы с различными типами данных, которые могут потребоваться в приложениях.

#### Различия между SQL и NoSQL запросами

MongoDB использует декларативный язык запросов, который отличается от SQL языка традиционных реляционных баз данных. В MongoDB запросы строятся как выражения в JSON-стиле, что позволяет выполнять сложные операции фильтрации, агрегации и обновления данных с использованием гибких и мощных конструкций. Например, в то время как в SQL для выборки данных используется `SELECT`, в MongoDB для получения данных используется метод `find()`.

#### Базовые операции в MongoDB (CRUD)

-   **Создание (Create):** Добавление новых документов в коллекцию с помощью операций вставки (`insertOne`, `insertMany`).
-   **Чтение (Read):** Получение данных из коллекции с помощью операций чтения (`find`, `findOne`).
-   **Обновление (Update):** Изменение существующих документов в коллекции (`updateOne`, `updateMany`, `replaceOne`).
-   **Удаление (Delete):** Удаление документов из коллекции (`deleteOne`, `deleteMany`).

### Создание базы данных и коллекций.

Для работы с MongoDB из Node.js мы можем воспользоваться официальным драйвером MongoDB для Node.js. Ниже приведен пример, который демонстрирует создание базы данных, коллекции и выполнение всех базовых операций CRUD (создание, чтение, обновление, удаление) в MongoDB из Node.js.

#### Шаг 1: Установка MongoDB Node.js Driver

Для начала убедитесь, что у вас установлен Node.js. Затем создайте новый проект и установите драйвер MongoDB для Node.js, используя NPM:

```bash
npm init -y
npm install mongodb
```

#### Шаг 2: Подключение к MongoDB

Создайте файл `index.js` и добавьте в него следующий код для подключения к MongoDB. Замените `<your_connection_string>` на вашу строку подключения к MongoDB:

```javascript
const { MongoClient } = require("mongodb");
const uri = "<your_connection_string>";
const client = new MongoClient(uri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});

async function run() {
    try {
        await client.connect();
        console.log("Connected successfully to MongoDB");
    } catch (err) {
        console.error(err);
    }
}

run().catch(console.dir);
```

#### Шаг 3: Создание базы данных и коллекции

MongoDB автоматически создает базу данных и коллекцию, когда вы впервые пытаетесь в них записать данные. Однако для демонстрации добавим явное создание коллекции:

```javascript
async function createCollection() {
    const database = client.db("myTestDB");
    const collection = database.collection("myTestCollection");
    console.log("Collection is created!");
    return collection; // Возвращаем коллекцию для дальнейшего использования
}
```

#### Шаг 4: Базовые операции (CRUD)

##### Создание (Insert)

```javascript
async function insertDocuments(collection) {
    const result = await collection.insertMany([
        { name: "Item1", price: 100 },
        { name: "Item2", price: 200 },
        { name: "Item3", price: 300 },
    ]);
    console.log(`${result.insertedCount} documents were inserted`);
}
```

##### Чтение (Find)

```javascript
async function findDocuments(collection) {
    const found = await collection.find({}).toArray();
    console.log("Found documents =>", found);
}
```

##### Обновление (Update)

```javascript
async function updateDocument(collection) {
    const result = await collection.updateOne(
        { name: "Item1" },
        { $set: { price: 150 } },
    );
    console.log(`${result.modifiedCount} document(s) was(were) updated`);
}
```

##### Удаление (Delete)

```javascript
async function deleteDocument(collection) {
    const result = await collection.deleteOne({ name: "Item3" });
    console.log(`${result.deletedCount} document(s) was(were) deleted`);
}
```

#### Шаг 5: Запуск операций

Для запуска всех операций включите вызовы функций в `run` функцию и вызовите `client.close()` в конце для закрытия подключения:

```javascript
async function run() {
    try {
        await client.connect();
        console.log("Connected successfully to MongoDB");

        const collection = await createCollection();
        await insertDocuments(collection);
        await findDocuments(collection);
        await updateDocument(collection);
        await deleteDocument(collection);
    } catch (err) {
        console.error(err);
    } finally {
        await client.close();
    }
}

run().catch(console.dir);
```

Замените `"myTestDB"` и `"myTestCollection"` на желаемые имена для вашей базы данных и коллекции. Не забудьте заменить `<your_connection_string>` на вашу актуальную строку подключения.

#### Шаг 6: Создание HTTP Сервера для Обработки Запросов

Добавьте в `index.js` следующий код для создания HTTP сервера, который будет обрабатывать запросы к вашему API:

```javascript
const http = require("http");
const { MongoClient } = require("mongodb");
const uri = "<your_connection_string>";
const client = new MongoClient(uri, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});

const server = http.createServer(async (req, res) => {
    const collection = client.db("myTestDB").collection("myTestCollection");
    let body = "";

    req.on("data", (chunk) => {
        body += chunk.toString(); // Преобразование потока данных в строку.
    });

    if (req.url.startsWith("/documents") && req.method === "POST") {
        req.on("end", async () => {
            try {
                const doc = JSON.parse(body);
                const result = await collection.insertOne(doc);
                res.writeHead(201, { "Content-Type": "application/json" });
                res.end(JSON.stringify(result.ops));
            } catch (error) {
                res.writeHead(500, { "Content-Type": "application/json" });
                res.end(JSON.stringify({ message: error.message }));
            }
        });
    } else if (req.url.startsWith("/documents") && req.method === "GET") {
        const docs = await collection.find({}).toArray();
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(docs));
    } else {
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ message: "Route not found" }));
    }
});

const PORT = 3000;
server.listen(PORT, async () => {
    try {
        await client.connect();
        console.log(`Server running on port ${PORT}`);
    } catch (err) {
        console.error(err);
    }
});
```

Этот код создает простой HTTP-сервер, который слушает порт 3000. Он может обрабатывать POST запросы для создания новых документов в коллекции `myTestCollection` базы данных `myTestDB` и GET запросы для чтения всех документов из этой коллекции.

#### Тестирование через Postman

1. **Создание документа (POST /documents):**

    - Откройте Postman и создайте новый POST запрос к `http://localhost:3000/documents`.
    - В теле запроса выберите `raw` и тип `JSON`, введите данные для нового документа, например, `{"name": "NewItem", "price": 500}`.
    - Отправьте запрос и проверьте ответ сервера и базу данных на наличие нового документа.

2. **Получение всех документов (GET /documents):**

    - Создайте новый GET запрос к `http://localhost:3000/documents`.
    - Отправьте запрос и проверьте ответ сервера, который должен содержать список всех документов в коллекции.

## Нормализация SQL и NoSQL баз данных

### Теория нормализации SQL

Теория нормализации в контексте SQL и реляционных баз данных является ключевым аспектом проектирования базы данных, направленным на уменьшение дублирования данных и обеспечение логической целостности. Нормализация включает в себя разделение таблицы на несколько связанных таблиц для устранения избыточности, улучшения целостности данных и упрощения модели данных. Процесс нормализации описывается через серию "нормальных форм" (НФ) (NF), каждая из которых устраняет определенные типы аномалий и избыточности.

#### Цели нормализации. Понимание аномалий данных.

Цели нормализации и понимание аномалий данных являются ключевыми аспектами проектирования реляционных баз данных, направленными на повышение их эффективности и целостности. Нормализация помогает структурировать базу данных таким образом, чтобы она была логически организована, избегая избыточности и упрощая поддержку данных. Рассмотрим цели нормализации и типы аномалий данных более подробно.

##### Цели нормализации

Основные цели нормализации баз данных включают:

1. **Уменьшение избыточности данных:** Избыточность данных приводит к дублированию информации в базе данных, что увеличивает занимаемый объем и может привести к несогласованности данных. Нормализация позволяет уменьшить дублирование, сокращая объем хранимых данных и упрощая их обновление.
2. **Устранение аномалий данных:** Аномалии вставки, обновления и удаления могут возникать в ненормализованных базах данных, приводя к потере целостности данных. Нормализация помогает предотвратить эти аномалии, обеспечивая более надежное и предсказуемое управление данными.
3. **Обеспечение целостности данных:** Целостность данных обеспечивается за счет того, что каждый логический набор информации хранится только в одном месте. Это упрощает поддержание точности и актуальности данных.
4. **Оптимизация запросов:** Нормализованные базы данных могут облегчить написание более эффективных запросов за счет уменьшения количества дублирующихся данных и упрощения структуры базы данных.

##### Аномалии данных

Аномалии данных — это проблемы, которые могут возникнуть в базе данных в результате неправильного проектирования. Существует три основных типа аномалий:

1. **Аномалии вставки:** Происходят, когда невозможно добавить данные в базу без добавления дополнительной, возможно нежелательной информации. Например, если для добавления информации о новом продукте необходимо включить данные о поставщике, даже если эти данные еще не известны.
2. **Аномалии обновления:** Возникают, когда изменение данных в одном месте требует множественных обновлений в разных местах базы данных. Это может привести к несогласованности данных, если обновление не выполнено полностью.
3. **Аномалии удаления:** Происходят, когда удаление набора данных приводит к непреднамеренному удалению важной информации. Например, если удаление данных о последнем заказе клиента приведет к удалению всей информации о клиенте.

#### Обзор нормальных форм от первой до третьей.

Нормальные формы — это уровни нормализации, которые помогают определить степень нормализации базы данных в реляционной модели. Они предназначены для уменьшения избыточности данных и улучшения логической структуры. Рассмотрим подробнее первую, вторую и третью нормальные формы.

#### Первая Нормальная Форма (1NF)

Для соответствия 1NF таблица должна удовлетворять следующим условиям:

-   **Атомарность значений:** Все значения в таблице должны быть атомарными, то есть не делимыми на более мелкие части. Например, если столбец содержит адреса, адрес не должен быть разделен на улицу, город и почтовый индекс в одной ячейке.
-   **Уникальность строк:** Каждая строка в таблице должна быть уникальной, что обычно достигается путем введения уникального идентификатора — первичного ключа.
-   **Однородность столбцов:** Все значения в каждом столбце должны быть одного и того же типа данных.

#### Вторая Нормальная Форма (2NF)

Таблица находится в 2NF, если она уже в 1NF и, кроме того, выполнено следующее условие:

-   **Устранение частичной зависимости:** Все не ключевые атрибуты должны полностью зависеть от первичного ключа. Это означает, что если первичный ключ составной, то каждый атрибут должен зависеть от всего ключа, а не от его части. Если какой-либо атрибут зависит только от части составного ключа, такие данные нужно вынести в отдельную таблицу.

#### Третья Нормальная Форма (3NF)

Таблица соответствует 3NF, если она находится в 2NF и выполнены следующие условия:

-   **Устранение транзитивной зависимости:** Не должно быть транзитивной зависимости не ключевых атрибутов от первичного ключа. Транзитивная зависимость существует, когда не ключевой атрибут зависит от других не ключевых атрибутов. Если А зависит от В, а В зависит от С, то А транзитивно зависит от С. В таком случае, данные, вызывающие транзитивную зависимость, следует вынести в отдельную таблицу.

#### Примеры

##### Пример 1NF

Не нормализованная таблица:

```
| ID | Имя        | Заказанные товары      |
|----|------------|-----------------------|
| 1  | Иван Иванов| Чай, Кофе              |
```

Таблица в 1NF:

```
| ID | Имя        | Заказанный товар |
|----|------------|------------------|
| 1  | Иван Иванов| Чай              |
| 1  | Иван Иванов| Кофе             |
```

##### Пример 2NF

Таблица в 1NF, но не в 2NF (потому что "Адрес" зависит только от "Имя", а не от всего составного ключа "ID" и "Заказанный товар"):

```
| ID | Имя        | Заказанный товар | Адрес         |
|----|------------|------------------|---------------|
| 1  | Иван Иванов| Чай              | Улица А, 1    |
| 1  | Иван Иванов| Кофе             | Улица А, 1

    |
```

Таблицы в 2NF:

```
Таблица Клиенты:
| Имя        | Адрес         |
|------------|---------------|
| Иван Иванов| Улица А, 1    |

Таблица Заказы:
| ID | Имя        | Заказанный товар |
|----|------------|------------------|
| 1  | Иван Иванов| Чай              |
| 1  | Иван Иванов| Кофе             |
```

##### Пример 3NF

Таблица в 2NF, но не в 3NF (потому что "Цена" транзитивно зависит от "Заказанный товар", а не от "ID"):

```
Таблица Заказы:
| ID | Заказанный товар | Цена |
|----|------------------|------|
| 1  | Чай              | 50   |
| 1  | Кофе             | 100  |
```

Таблицы в 3NF:

```
Таблица Заказы:
| ID | Заказанный товар |
|----|------------------|
| 1  | Чай              |
| 1  | Кофе             |

Таблица Цены:
| Заказанный товар | Цена |
|------------------|------|
| Чай              | 50   |
| Кофе             | 100  |
```

Нормализация до 3NF помогает уменьшить избыточность, облегчает обновление данных и увеличивает целостность базы данных.

#### Анализ таблиц на предмет нарушений нормальных форм.

Давайте рассмотрим пример таблицы и проанализируем её на предмет нарушений нормальных форм. Для наглядности возьмем таблицу с заказами и продуктами.

##### Пример таблицы "Заказы и Продукты"

Предположим, у нас есть таблица, которая хранит информацию о заказах и продуктах:

```
| Заказ № | Клиент   | Продукт | Цена |
|---------|----------|---------|------|
| 1       | Иванов   | Чай     | 50   |
| 1       | Иванов   | Кофе    | 100  |
| 2       | Петров   | Чай     | 50   |
| 2       | Петров   | Сахар   | 30   |
| 3       | Сидоров  | Кофе    | 100  |
```

Эта таблица имеет следующие проблемы, нарушающие нормальные формы:

##### Проблема 1: Повторяющиеся данные

Данные о клиентах (столбец "Клиент") и продуктах (столбец "Продукт") повторяются в нескольких строках. Это приводит к избыточности данных и усложняет обновление информации о клиентах и продуктах.

##### Проблема 2: Транзитивная зависимость

Цена (столбец "Цена") зависит от продукта (столбец "Продукт"), но также транзитивно зависит от заказа (столбец "Заказ №"). Это нарушает третью нормальную форму (3NF), так как цена должна зависеть только от первичного ключа (заказа), но не от атрибутов, которые не являются его частью.

##### Как исправить нарушения нормальных форм

Для устранения нарушений нормальных форм, мы можем разделить эту таблицу на две нормализованные таблицы: "Заказы" и "Продукты". Вот как это можно сделать:

##### Таблица "Заказы"

```
| Заказ № | Клиент   |
|---------|----------|
| 1       | Иванов   |
| 2       | Петров   |
| 3       | Сидоров  |
```

##### Таблица "Продукты"

```
| Продукт | Цена |
|---------|------|
| Чай     | 50   |
| Кофе    | 100  |
| Сахар   | 30   |
```

Теперь данные о клиентах и продуктах не повторяются, и цена привязана только к продукту, что соответствует третьей нормальной форме (3NF).

#### Практическое задание: Нормализация таблицы до третьей нормальной формы.

Давайте рассмотрим более крупный пример и выполним нормализацию таблицы до третьей нормальной формы (3NF). Предположим, у нас есть таблица "Университет" с информацией о студентах, курсах и оценках.

##### Исходная таблица "Университет"

```
| Студент | Курс       | Преподаватель | Оценка |
|---------|------------|---------------|--------|
| Иван    | Математика | Проф. Сидоров | 5      |
| Иван    | Физика     | Проф. Петров  | 4      |
| Мария   | Математика | Проф. Сидоров | 4      |
| Мария   | История    | Проф. Иванов  | 5      |
| Петр    | Физика     | Проф. Петров  | 3      |
```

Эта таблица имеет несколько проблем, таких как повторяющиеся данные и транзитивная зависимость. Давайте проведем нормализацию:

##### Шаг 1: Создание таблицы "Студенты"

```
| Студент |
|---------|
| Иван    |
| Мария   |
| Петр    |
```

В этой таблице мы храним уникальные идентификаторы студентов.

##### Шаг 2: Создание таблицы "Курсы"

```
| Курс       | Преподаватель |
|------------|---------------|
| Математика | Проф. Сидоров |
| Физика     | Проф. Петров  |
| История    | Проф. Иванов  |
```

В этой таблице мы храним уникальные курсы и их преподавателей.

##### Шаг 3: Создание таблицы "Оценки"

```
| Студент | Курс       | Оценка |
|---------|------------|--------|
| Иван    | Математика | 5      |
| Иван    | Физика     | 4      |
| Мария   | Математика | 4      |
| Мария   | История    | 5      |
| Петр    | Физика     | 3      |
```

В этой таблице мы храним информацию об оценках студентов по курсам. Обратите внимание, что мы больше не храним повторяющиеся данные о преподавателях, так как они зависят от курсов, а не от студентов.

Теперь наша база данных соответствует третьей нормальной форме (3NF), и у нас нет повторяющихся данных или транзитивных зависимостей.

Нормализация данных помогает улучшить целостность данных, снизить избыточность и обеспечить более эффективное управление информацией в базе данных.

### Теория нормализации NoSQL в контексте MongoDB

Нормализация в контексте MongoDB, документо-ориентированной NoSQL базы данных, отличается от подхода, используемого в реляционных базах данных. В MongoDB данные часто хранятся денормализованно для увеличения производительности за счет уменьшения количества операций чтения. Однако, в некоторых случаях, нормализация данных может быть полезна и в MongoDB, например, для уменьшения дублирования данных и обеспечения целостности данных.

#### Понимание Нормализации в MongoDB

В MongoDB нормализация — это процесс разделения данных на отдельные коллекции с созданием ссылок между ними, аналогично внешним ключам в реляционных базах данных. Это может помочь:

-   Уменьшить дублирование данных.
-   Упростить обновление данных, обеспечивая их целостность.
-   Оптимизировать использование памяти за счет избегания хранения одних и тех же данных в нескольких местах.

#### Пример Нормализации в MongoDB

Допустим, у нас есть приложение для ведения блога, и мы хотим хранить информацию о пользователях и их постах. В денормализованной структуре мы могли бы хранить посты непосредственно в документе пользователя:

```json
{
  "_id": ObjectId("5f8d4fe2f5d85e8e51ff9b28"),
  "username": "user1",
  "posts": [
    {
      "title": "Пост 1",
      "content": "Содержание поста 1",
      "date": ISODate("2020-10-20T12:00:00Z")
    },
    {
      "title": "Пост 2",
      "content": "Содержание поста 2",
      "date": ISODate("2020-10-21T12:00:00Z")
    }
  ]
}
```

#### Нормализация:

1. **Пользователи:**

```json
{
  "_id": ObjectId("5f8d4fe2f5d85e8e51ff9b28"),
  "username": "user1"
}
```

2. **Посты:**

```json
[
  {
    "_id": ObjectId("5f8d4fe2f5d85e8e51ffa123"),
    "authorId": ObjectId("5f8d4fe2f5d85e8e51ff9b28"),
    "title": "Пост 1",
    "content": "Содержание поста 1",
    "date": ISODate("2020-10-20T12:00:00Z")
  },
  {
    "_id": ObjectId("5f8d4fe2f5d85e8e51ffb234"),
    "authorId": ObjectId("5f8d4fe2f5d85e8e51ff9b28"),
    "title": "Пост 2",
    "content": "Содержание поста 2",
    "date": ISODate("2020-10-21T12:00:00Z")
  }
]
```

В нормализованной структуре каждый пост становится отдельным документом в коллекции `posts`, с ссылкой на `_id` пользователя в поле `authorId`. Это позволяет управлять постами независимо от пользователей, упрощая обновление, добавление и удаление постов.

#### Когда Нормализовать

Нормализация в MongoDB может быть полезна, когда:

-   **Данные часто обновляются:** Изменение данных в одном месте упрощает поддержку и предотвращает ошибки.
-   **Избегание дублирования данных:** Снижает использование дискового пространства и упрощает обновление данных.
-   **Отношения между данными сложные и глубокие:** Когда отношения между данными становятся слишком сложными для удобного представления в одном документе.

#### Когда Использовать Денормализацию

Денормализация предпочтительна, когда:

-   **Чтение данных происходит гораздо чаще, чем их обновление:** Денормализация может ускорить чтение за счет увеличения избыточности данных.
-   **Необходимость оптимизации производительности чтения:** Снижение количества необходимых операций объединения может значительно увеличить скорость чтения данных.

Выбор между нормализацией и денормализацией в MongoDB зависит от конкретных требований приложения и желаемого баланса между скоростью чтения и удобством обновления данных.

## Применение MongoDB и Mongoose. Понимание нормализации в реальных проектах

### Применение MongoDB и Mongoose в проектах

**Интеграция MongoDB в проекты** включает в себя несколько ключевых шагов:

1. **Установка MongoDB**: Начните с установки MongoDB на ваш сервер или локальный компьютер. MongoDB предлагает различные варианты для различных операционных систем.
2. **Настройка базы данных**: После установки настройте свою базу данных, создайте необходимые коллекции (аналог таблиц в реляционных базах данных) и настройте параметры доступа.
3. **Интеграция с проектом**: Для работы с MongoDB в вашем Node.js проекте установите Mongoose через npm: `npm install mongoose`. Это позволит вам использовать схемы, модели и запросы Mongoose для управления данными.
4. **Моделирование данных**: С помощью Mongoose определите схемы данных, которые описывают структуру ваших документов в MongoDB, включая типы полей, валидацию и методы экземпляра.
5. **Работа с данными**: Используйте модели Mongoose для создания, чтения, обновления и удаления (CRUD) данных в вашей базе. Mongoose предоставляет множество удобных методов для этих операций.

### Понимание нормализации в реальных проектах

Нормализация – это процесс организации данных в базе данных для снижения избыточности и улучшения целостности данных. В контексте реляционных баз данных, нормализация достигается путем разделения данных на несколько связанных таблиц.

В MongoDB, хотя она не реляционная, концепция нормализации все еще применима в форме ссылок между документами. Вы можете "нормализовать" данные, сохраняя ссылки на документы из других коллекций, вместо того чтобы дублировать данные. Это обеспечивает гибкость и эффективность при работе с связанными данными.

**Пример**: Если у вас есть коллекция пользователей и коллекция комментариев, каждый комментарий может содержать идентификатор пользователя, который его создал, вместо того чтобы дублировать информацию о пользователе в каждом комментарии.

**Преимущества**:

-   **Гибкость**: Модель данных может быть легко изменена без необходимости перестраивать таблицы.
-   **Масштабируемость**: MongoDB хорошо подходит для работы с большими объемами данных и сложными запросами.

**Недостатки**:

-   **Запросы по нескольким коллекциям**: Для получения полной информации может потребоваться выполнение нескольких запросов и их объединение на стороне приложения.

Интеграция MongoDB и использование Mongoose в проектах позволяет разработчикам эффективно управлять данными и об

еспечивает мощный инструментарий для работы с нереляционными базами данных. Однако, как и в любом выборе технологии, важно понимать требования вашего проекта и соответствующим образом принимать решения о структуре данных.

### Обзор Mongoose для работы с MongoDB

Mongoose является популярной библиотекой для Node.js, которая служит в качестве моста между базой данных MongoDB и веб-приложением, облегчая процесс моделирования данных приложения. Она предоставляет простой API для создания схем данных, валидации, составления запросов и работы с результатами.

#### Основные концепции Mongoose

**Схемы**: Схема в Mongoose определяет структуру данных документа (соответствующего записи в базе данных) с помощью определенного набора типов данных и валидации. Схемы также могут определять методы и статические функции для документов.

**Модели**: Модель Mongoose – это обертка для схемы, которая предоставляет интерфейс для создания, запроса, обновления и удаления документов в базе данных.

#### Пример использования Mongoose

Допустим, у нас есть веб-приложение, которое работает с базой данных пользователей. Ниже приведен пример, как можно использовать Mongoose для работы с данными пользователей.

**Шаг 1. Установка и подключение Mongoose**

Первым делом необходимо установить Mongoose через npm:

```bash
npm install mongoose
```

Затем подключаемся к MongoDB через Mongoose:

```javascript
const mongoose = require("mongoose");

mongoose.connect("mongodb://localhost/mydatabase", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});
```

**Шаг 2. Определение схемы**

Определим схему для пользователя:

```javascript
const userSchema = new mongoose.Schema({
    name: String,
    age: Number,
    email: {
        type: String,
        required: true,
        unique: true,
    },
});
```

**Шаг 3. Создание модели**

Создадим модель, основанную на схеме пользователя:

```javascript
const User = mongoose.model("User", userSchema);
```

**Шаг 4. Использование модели для работы с данными**

Теперь мы можем использовать модель `User` для создания новых пользователей, поиска существующих, обновления и удаления.

-   **Создание нового пользователя**:

```javascript
const newUser = new User({
    name: "Ivan Ivanov",
    age: 30,
    email: "ivan@example.com",
});

newUser.save().then(() => console.log("User created"));
```

-   **Поиск пользователей**:

```javascript
User.find({ age: { $gt: 20 } }, function (err, users) {
    if (err) throw err;
    console.log(users);
});
```

-   **Обновление пользователя**:

```javascript
User.findOneAndUpdate(
    { name: "Ivan Ivanov" },
    { age: 31 },
    function (err, user) {
        if (err) throw err;
        console.log("User updated");
    },
);
```

-   **Удаление пользователя**:

```javascript
User.findOneAndDelete({ name: "Ivan Ivanov" }, function (err) {
    if (err) throw err;
    console.log("User deleted");
});
```

Этот пример иллюстрирует базовые операции CRUD (создание, чтение, обновление, удаление) с использованием Mongoose. Mongoose предлагает гораздо больше возможностей для управления данными, включая валидацию, настройку схем и работы с сложными запросами.

## Приложение на Node.js для взаимодействия с книгами, используя MongoDB

Давайте создадим простое приложение на Node.js для взаимодействия с книгами, используя MongoDB для хранения данных, без использования фреймворка Express. Приложение будет предоставлять базовый HTTP-сервер, который позволяет добавлять книги в базу данных и получать список всех книг.

### Шаг 1: Установка необходимых пакетов

Установите Mongoose для взаимодействия с MongoDB:

```bash
pnpm install mongoose
```

### Шаг 2: Создание модели книги

Создайте файл `book.js` для определения модели книги:

```javascript
const mongoose = require("mongoose");

const bookSchema = new mongoose.Schema({
    title: { type: String, required: true },
    author: { type: String, required: true },
    year: Number,
});

const Book = mongoose.model("Book", bookSchema);

module.exports = Book;
```

### Шаг 3: Создание сервера

Создайте файл `server.js`:

```javascript
const http = require("http");
const mongoose = require("mongoose");
const Book = require("./book");

const databaseUrl = "mongodb://localhost:27017/bookstore";
mongoose.connect(databaseUrl, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});

const db = mongoose.connection;
db.on("error", console.error.bind(console, "MongoDB connection error:"));

const server = http.createServer(async (req, res) => {
    if (req.url === "/books" && req.method === "GET") {
        // Получение списка всех книг
        const books = await Book.find();
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(books));
    } else if (req.url === "/books" && req.method === "POST") {
        // Добавление новой книги
        let body = "";
        req.on("data", (chunk) => {
            body += chunk.toString();
        });
        req.on("end", async () => {
            const { title, author, year } = JSON.parse(body);
            const book = new Book({ title, author, year });
            await book.save();
            res.writeHead(201, { "Content-Type": "application/json" });
            res.end(JSON.stringify(book));
        });
    } else {
        res.writeHead(404, { "Content-Type": "text/plain" });
        res.end("Not Found");
    }
});

const port = 3000;
server.listen(port, () =>
    console.log(`Server running at http://localhost:${port}/`),
);
```

Этот сервер обрабатывает два типа запросов: `GET /books` для получения списка всех книг и `POST /books` для добавления новой книги. Данные для новой книги отправляются в формате JSON.

### Шаг 4: Запуск сервера

Запустите ваш сервер:

```bash
nodemon server.js
```

Теперь сервер работает и слушает порт 3000. Вы можете отправлять запросы на добавление книг и получение списка книг.

### Шаг 5: Улучшения структуры проекта и добавления дополнительных функций

Для улучшения структуры проекта и добавления дополнительных функций (создание, изменение и удаление книг по идентификатору) мы можем разделить логику на несколько файлов. Вот как можно организовать проект:

### Шаг 6: Рефакторинг создания книги

Создайте папку `controllers` и внутри неё файл `bookController.js`. Этот файл будет содержать логику управления книгами.

**controllers/bookController.js**:

```javascript
const Book = require("../book");

// Добавление новой книги
async function addBook(req, res) {
    let body = "";
    req.on("data", (chunk) => {
        body += chunk.toString();
    });
    req.on("end", async () => {
        const { title, author, year } = JSON.parse(body);
        const book = new Book({ title, author, year });
        await book.save();
        res.writeHead(201, { "Content-Type": "application/json" });
        res.end(JSON.stringify(book));
    });
}

// Получение списка всех книг
async function getBooks(req, res) {
    const books = await Book.find();
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify(books));
}

// Получение книги по ID
async function getBookById(req, res, id) {
    try {
        const book = await Book.findById(id);
        if (!book) {
            res.writeHead(404, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ message: "Book not found" }));
        } else {
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify(book));
        }
    } catch (error) {
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ message: "Book not found" }));
    }
}

// Обновление книги по ID
async function updateBook(req, res, id) {
    let body = "";
    req.on("data", (chunk) => {
        body += chunk.toString();
    });
    req.on("end", async () => {
        const { title, author, year } = JSON.parse(body);
        const book = await Book.findByIdAndUpdate(
            id,
            { title, author, year },
            { new: true },
        );
        if (!book) {
            res.writeHead(404, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ message: "Book not found" }));
        } else {
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify(book));
        }
    });
}

// Удаление книги по ID
async function deleteBook(req, res, id) {
    try {
        const book = await Book.findByIdAndDelete(id);
        if (!book) {
            res.writeHead(404, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ message: "Book not found" }));
        } else {
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ message: "Book deleted" }));
        }
    } catch (error) {
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ message: "Book not found" }));
    }
}

module.exports = {
    addBook,
    getBooks,
    getBookById,
    updateBook,
    deleteBook,
};
```

### Шаг 7: Изменение сервера для использования контроллеров

Измените `server.js`, чтобы использовать функции из `bookController.js`:

```javascript
const http = require("http");
const mongoose = require("mongoose");
const {
    addBook,
    getBooks,
    getBookById,
    updateBook,
    deleteBook,
} = require("./controllers/bookController");

const databaseUrl = "mongodb://localhost:27017/bookstore";
mongoose.connect(databaseUrl, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});
const db = mongoose.connection;
db.on("error", console.error.bind(console, "MongoDB connection error:"));

const server = http.createServer((req, res) => {
    const reqUrl = req.url;
    // Разбор URL для получения ID
    const idRegex = /\/books\/([0-9a-fA-F]{24})/;
    const found = reqUrl.match(idRegex);
    const id = found ? found[1] : null;

    if (reqUrl === "/books" && req.method === "GET") {
        getBooks(
            req,

            res,
        );
    } else if (reqUrl === "/books" && req.method === "POST") {
        addBook(req, res);
    } else if (id && req.method === "GET") {
        getBookById(req, res, id);
    } else if (id && req.method === "PUT") {
        updateBook(req, res, id);
    } else if (id && req.method === "DELETE") {
        deleteBook(req, res, id);
    } else {
        res.writeHead(404, { "Content-Type": "text/plain" });
        res.end("Not Found");
    }
});

const port = 3000;
server.listen(port, () =>
    console.log(`Server running at http://localhost:${port}/`),
);
```

Теперь ваш сервер поддерживает создание, получение, обновление и удаление книг по их идентификаторам.

### Шаг 8: Запуск и тестирование

Убедитесь, что MongoDB запущен, и запустите сервер:

```bash
node server.js
```

Используйте инструменты вроде Postman или cURL для тестирования эндпоинтов:

-   Добавление книги (POST `/books`)
-   Получение всех книг (GET `/books`)
-   Получение книги по ID (GET `/books/:id`)
-   Обновление книги по ID (PUT `/books/:id`)
-   Удаление книги по ID (DELETE `/books/:id`)

Этот подход помогает организовать код более чисто и позволяет легко расширять функциональность приложения в будущем.
