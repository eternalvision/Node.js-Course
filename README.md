# Расширенные SQL запросы и многотабличные базы данных

## Продвинутые SQL запросы

### Операторы UNION и UNION ALL

#### Введение в операторы UNION и UNION ALL

Операторы `UNION` и `UNION ALL` предоставляют возможность объединить результаты нескольких SQL запросов в один результат. Они являются мощными инструментами для комбинирования данных из разных таблиц или запросов. Однако, есть важные различия между этими операторами, которые необходимо учитывать.

#### Оператор UNION

Оператор `UNION` используется для объединения результатов двух или более SQL запросов в одну единую выборку. Он удаляет дублирующиеся строки из результатов, что делает его полезным, если вы хотите объединить уникальные записи.

Синтаксис оператора `UNION`:

```sql
SELECT column1, column2, ...
FROM table1
UNION
SELECT column1, column2, ...
FROM table2;
```

Пример использования оператора `UNION`:

```sql
SELECT first_name, last_name
FROM employees
UNION
SELECT first_name, last_name
FROM contractors;
```

В данном примере, оператор `UNION` объединяет имена сотрудников и контрактников без дублирования имен.

#### Оператор UNION ALL

Оператор `UNION ALL`, в отличие от `UNION`, не удаляет дублирующиеся строки из результатов. Он объединяет все строки из всех запросов в один набор результатов, включая повторяющиеся записи.

Синтаксис оператора `UNION ALL`:

```sql
SELECT column1, column2, ...
FROM table1
UNION ALL
SELECT column1, column2, ...
FROM table2;
```

Пример использования оператора `UNION ALL`:

```sql
SELECT city
FROM customers
UNION ALL
SELECT city
FROM suppliers;
```

В этом примере, оператор `UNION ALL` объединяет города из таблицы клиентов и поставщиков, включая все записи, даже если они повторяются.

#### Когда использовать UNION и UNION ALL

-   Используйте `UNION`, если вы хотите объединить уникальные записи и удалить дубликаты.
-   Используйте `UNION ALL`, если вам нужны все строки из результатов, включая дублирующиеся записи.

Практические примеры

1. Выбор всех уникальных городов из таблицы клиентов и поставщиков:

```sql
SELECT city
FROM customers
UNION
SELECT city
FROM suppliers;
```

2. Выбор всех городов из таблицы клиентов и поставщиков с сохранением дубликатов:

```sql
SELECT city
FROM customers
UNION ALL
SELECT city
FROM suppliers;
```

#### Различия между UNION и UNION ALL.

##### Оператор UNION

1. **Удаление дубликатов:** Основное различие между `UNION` и `UNION ALL` заключается в том, что `UNION` удаляет дубликаты строк из результатов и возвращает только уникальные записи. Это означает, что если есть одинаковые строки в результатах запросов, то `UNION` оставит только одну из них.
2. **Производительность:** Из-за удаления дубликатов `UNION` может быть менее производительным, чем `UNION ALL`. Это связано с дополнительной операцией удаления дубликатов, которая может потреблять ресурсы.
3. **Синтаксис:** Синтаксис оператора `UNION` выглядит следующим образом:

```sql
SELECT column1, column2, ...
FROM table1
UNION
SELECT column1, column2, ...
FROM table2;
```

##### Оператор UNION ALL

1. **Сохранение дубликатов:** В отличие от `UNION`, `UNION ALL` не удаляет дублирующиеся строки из результатов. Это означает, что если есть одинаковые строки в результатах запросов, то `UNION ALL` сохранит все их копии.
2. **Производительность:** `UNION ALL` может быть более производительным, чем `UNION`, так как он не выполняет операцию удаления дубликатов. Если вам не нужно удалять дубликаты и вы знаете, что результаты запросов не содержат дубликатов, лучше использовать `UNION ALL`.
3. **Синтаксис:** Синтаксис оператора `UNION ALL` аналогичен `UNION`:

```sql
SELECT column1, column2, ...
FROM table1
UNION ALL
SELECT column1, column2, ...
FROM table2;
```

### Многотабличные запросы, JOIN

#### Что такое JOIN?

Оператор JOIN используется для объединения данных из двух или более таблиц на основе определенных условий. Он позволяет получить информацию из нескольких таблиц в одном запросе.

#### Типы JOIN в SQL

1. **INNER JOIN:** Возвращает только те строки, которые имеют соответствующие значения в обеих таблицах.
2. **LEFT JOIN (или LEFT OUTER JOIN):** Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если нет соответствующих строк в правой таблице, то будут возвращены NULL значения.
3. **RIGHT JOIN (или RIGHT OUTER JOIN):** Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если нет соответствующих строк в левой таблице, то будут возвращены NULL значения.
4. **FULL OUTER JOIN (или FULL JOIN):** Возвращает все строки из обеих таблиц. Если нет соответствующих строк в одной из таблиц, то будут возвращены NULL значения.

#### Пример многотабличного запроса с использованием INNER JOIN

Предположим, у нас есть две таблицы: `users` и `orders`. Таблица `users` содержит информацию о пользователях, а таблица `orders` - информацию о заказах, включая идентификатор пользователя (`user_id`), связанный с каждым заказом.

```sql
-- Создаем таблицу пользователей (users)
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

-- Создаем таблицу заказов (orders)
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    total_amount DECIMAL(10, 2),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Заполняем таблицу пользователей (users)
INSERT INTO users (user_id, username, email)
VALUES
    (1, 'User1', 'user1@example.com'),
    (2, 'User2', 'user2@example.com'),
    (3, 'User3', 'user3@example.com');

-- Заполняем таблицу заказов (orders)
INSERT INTO orders (order_id, user_id, order_date, total_amount)
VALUES
    (101, 1, '2023-01-15', 100.00),
    (102, 1, '2023-02-20', 150.50),
    (103, 2, '2023-01-10', 75.25),
    (104, 3, '2023-03-05', 200.00);
```

Теперь давайте выполним многотабличный запрос с использованием INNER JOIN, чтобы получить информацию о пользователях и их заказах:

```sql
SELECT users.username, orders.order_id, orders.order_date, orders.total_amount
FROM users
INNER JOIN orders ON users.user_id = orders.user_id;
```

Результат будет содержать информацию о пользователях и их заказах, объединенную на основе `user_id`. Этот запрос вернет только заказы, которые имеют соответствующего пользователя, используя INNER JOIN.

### Функции агрегирования

#### COUNT()

Функция COUNT() используется для подсчета числа строк в группе.

Пример:

```sql
SELECT COUNT(*) FROM orders;
```

#### SUM()

Функция SUM() используется для вычисления суммы значений в столбце.

Пример:

```sql
SELECT SUM(total_amount) FROM orders;
```

#### AVG()

Функция AVG() используется для вычисления среднего значения в столбце.

Пример:

```sql
SELECT AVG(total_amount) FROM orders;
```

#### MIN()

Функция MIN() используется для нахождения минимального значения в столбце.

Пример:

```sql
SELECT MIN(order_date) FROM orders;
```

#### MAX()

Функция MAX() используется для нахождения максимального значения в столбце.

Пример:

```sql
SELECT MAX(total_amount) FROM orders;
```

Для примеров функций агрегирования и группировки с использованием SQL, давайте создадим две таблицы: `orders` и `sales`. Таблица `orders` будет содержать информацию о заказах, а таблица `sales` - информацию о продажах.

Пример создания таблицы `orders`:

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    order_date DATE,
    total_amount DECIMAL(10, 2)
);

-- Заполним таблицу `orders` данными
INSERT INTO orders (order_id, order_date, total_amount)
VALUES
    (1, '2023-01-15', 100.00),
    (2, '2023-01-20', 150.50),
    (3, '2023-02-10', 75.25),
    (4, '2023-02-15', 200.00),
    (5, '2023-03-05', 120.75);
```

Пример создания таблицы `sales`:

```sql
CREATE TABLE sales (
    sale_id INT PRIMARY KEY,
    sale_date DATE,
    sale_amount DECIMAL(10, 2)
);

-- Заполним таблицу `sales` данными
INSERT INTO sales (sale_id, sale_date, sale_amount)
VALUES
    (1, '2023-01-15', 50.00),
    (2, '2023-01-20', 75.50),
    (3, '2023-02-10', 30.25),
    (4, '2023-02-15', 100.00),
    (5, '2023-03-05', 60.75);
```

Теперь у нас есть две таблицы `orders` и `sales`, которые содержат данные о заказах и продажах.

Мы можем использовать функции агрегирования и группировки для выполнения запросов к этим данным. Например, следующий запрос найдет сумму продаж для каждой уникальной даты:

#### Группировка с использованием функций агрегирования

Часто функции агрегирования используются с оператором GROUP BY для выполнения агрегаций внутри групп строк. Например, если у вас есть таблица `sales` с информацией о продажах и датами, вы можете использовать GROUP BY для агрегирования продаж по датам.

Пример:

```sql
SELECT order_date, SUM(total_amount)
FROM orders
GROUP BY order_date;
```

Этот запрос вернет сумму продаж для каждой уникальной даты заказа.

#### Фильтрация групп с использованием HAVING

Чтобы фильтровать результаты агрегирования, вы можете использовать оператор HAVING. Например, если вы хотите найти даты с общей суммой продаж выше определенного значения:

Пример:

```sql
SELECT order_date, SUM(total_amount)
FROM orders
GROUP BY order_date
HAVING SUM(total_amount) > 100;
```

Этот запрос вернет даты с общей суммой продаж более 100.

### Операторы подзапросов

Подзапросы являются одним из самых мощных инструментов в `SQL`, который можно использовать в любых видах запросов. В ближайших уроках мы познакомимся с основными типами подзапросов и рассмотрим примеры как их можно использовать.

**Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.**

Операторы подзапросов позволяют включать один SQL запрос внутри другого SQL запроса. Это мощный механизм, который позволяет получать данные более сложными и гибкими способами, а также выполнять операции с данными в зависимости от результатов вложенных запросов.

#### Создание таблицы "employees" и "salaries" для демонстрации работы подзапросов.

```sql
-- Создание таблицы employees
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  employee_name VARCHAR(50),
  salary NUMERIC(10, 2),
  department VARCHAR(50)
);

-- Вставка примерных данных в таблицу employees
INSERT INTO employees (employee_name, salary, department)
VALUES
  ('John Doe', 60000, 'IT'),
  ('Jane Smith', 55000, 'HR'),
  ('Bob Johnson', 70000, 'IT'),
  ('Alice Williams', 58000, 'HR');

-- Создание таблицы salaries
CREATE TABLE salaries (
  id SERIAL PRIMARY KEY,
  employee_id INT,
  salary NUMERIC(10, 2),
  FOREIGN KEY (employee_id) REFERENCES employees(id)
);

-- Вставка примерных данных в таблицу salaries
INSERT INTO salaries (employee_id, salary)
VALUES
  (1, 60000),
  (2, 55000),
  (3, 70000),
  (4, 58000);
```

#### Типы операторов подзапросов

##### Подзапрос в операторе SELECT (Scalar Subquery)

Этот тип подзапросов возвращает единственное значение и может быть использован в качестве столбца в основном запросе. Например:

```sql
SELECT employee_name, (SELECT MAX(salary) FROM salaries) AS max_salary
FROM employees;
```

##### Подзапрос в операторе WHERE (Single-Row Subquery)

Подзапрос, используемый в операторе WHERE, возвращает одну строку и может быть использован для фильтрации результатов основного запроса. Например:

```sql
SELECT product_name
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

##### Подзапрос в операторе FROM (Derived Table)

Этот вид подзапроса используется в качестве временной таблицы в операторе FROM. Например:

```sql
SELECT *
FROM (SELECT employee_name, salary FROM employees WHERE department = 'IT') AS it_employees;
```

##### Подзапрос в операторе EXISTS (EXISTS Subquery)

Оператор EXISTS проверяет существование результатов подзапроса и возвращает TRUE или FALSE. Например:

```sql
SELECT employee_name
FROM employees
WHERE EXISTS (SELECT 1 FROM salaries WHERE employee_id = employees.id AND salary > 50000);
```

##### Практические примеры использования подзапросов

1. Выбор сотрудников с максимальной зарплатой:

```sql
SELECT employee_name
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```

2. Подсчет количества продуктов в каждой категории:

```sql
SELECT category_name, (SELECT COUNT(*) FROM products WHERE category_id = categories.id) AS product_count
FROM categories;
```

3. Выбор клиентов, у которых нет заказов:

```sql
SELECT customer_name
FROM customers
WHERE NOT EXISTS (SELECT 1 FROM orders WHERE orders.customer_id = customers.id);
```

#### Более глубокое изучение подзапросов и их роли в сложных запросах.

##### Роль подзапросов в сложных запросах

1. **Фильтрация данных:** Подзапросы могут использоваться для фильтрации данных в основном запросе. Например, можно использовать подзапрос, чтобы получить список идентификаторов, которые затем используются для выборки соответствующих записей из другой таблицы.
2. **Сравнение значений:** Подзапросы позволяют сравнивать значения из основного запроса с результатами других запросов. Это полезно при поиске значений, которые соответствуют определенным критериям.
3. **Создание вычисляемых столбцов:** Подзапросы могут использоваться для вычисления дополнительных столбцов в основном запросе. Например, можно создать столбец, который содержит результаты агрегатных функций или суммирования значений из другой таблицы.

##### Примеры использования подзапросов

**Выбор сотрудников с наивысшей зарплатой**

```sql
SELECT first_name, last_name, salary
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```

В этом запросе подзапрос возвращает максимальную зарплату из таблицы `employees`, которую затем сравнивают с зарплатой каждого сотрудника для выбора сотрудников с наивысшей зарплатой.

**Получение списка клиентов, не сделавших заказов**

```sql
SELECT customer_name
FROM customers
WHERE customer_id NOT IN (SELECT DISTINCT customer_id FROM orders);
```

Здесь подзапрос возвращает список уникальных `customer_id`, сделавших заказы, и основной запрос выбирает клиентов, которые не входят в этот список.

**Преимущества использования подзапросов**

-   Улучшение читаемости кода: Подзапросы позволяют разбить сложные запросы на более мелкие и читаемые части.
-   Возможность создавать динамические запросы: Подзапросы могут быть динамическими и зависеть от результатов других запросов.
-   Повышение гибкости: Подзапросы позволяют создавать запросы, которые адаптируются к различным сценариям.

## Работа с Node.js и PostgreSQL

### Подключение к базе данных в Node.js

Для работы с PostgreSQL в среде Node.js, необходимо установить соответствующие библиотеки и настроить подключение к базе данных. В этом разделе мы рассмотрим, как это сделать.

#### Установка библиотеки `pg`

Для начала, установим библиотеку `pg`, которая предоставляет драйвер PostgreSQL для Node.js. Выполните следующую команду в вашем проекте:

```bash
npm install pg
```

#### Настройка подключения к базе данных

Для подключения к PostgreSQL базе данных, вам потребуется информация о сервере базы данных, такая как хост, порт, имя базы данных, имя пользователя и пароль. Эту информацию можно передать в объекте конфигурации подключения.

#### Конфигурация подключения.

```javascript
const { Pool } = require("pg");

const pool = new Pool({
    user: "your_username",
    host: "your_host",
    database: "your_database",
    password: "your_password",
    port: 5432, // Порт, на котором работает PostgreSQL
});
```

В этом примере мы создаем новый экземпляр `Pool` из библиотеки `pg` и передаем ему объект конфигурации, включая имя пользователя, хост, имя базы данных и пароль. Вы можете настроить порт в соответствии с настройками вашего PostgreSQL сервера.

#### Подключение к базе данных

После настройки объекта `Pool`, вы можете использовать его для установления соединения с базой данных. Обычно соединение устанавливается в начале приложения и закрывается при завершении работы.

Пример установки и закрытия соединения:

```javascript
// Установка соединения с базой данных
pool.connect((err, client) => {
    if (err) {
        console.error("Ошибка при подключении к базе данных", err);
    } else {
        console.log("Подключение к базе данных установлено");

        // Ваши SQL запросы и операции с базой данных здесь

        // Закрытие соединения при завершении работы
        client.release();
    }
});
```

В приведенном коде мы используем метод `pool.connect()` для установки соединения с базой данных. Внутри функции обратного вызова мы можем выполнять SQL запросы и операции с базой данных. После завершения работы с базой данных, мы вызываем `client.release()` для закрытия соединения и возвращения его в пул соединений.

#### SQL запрос с использованием `pool.query()`:

```javascript
pool.query("SELECT * FROM your_table", (error, results) => {
    if (error) {
        throw error;
    }
    console.log(results.rows);
    pool.end(); // Закрываем соединение с базой данных
});
```

#### Выполнение запросов UNION, подзапросов и других продвинутых SQL операций через Node.js.

Для выполнения запросов `UNION` с помощью Node.js, вы можете использовать библиотеку `pg-promise`, которая облегчает взаимодействие с PostgreSQL из JavaScript кода.

Пример выполнения запроса `UNION` с использованием `pg-promise`:

```javascript
const pgp = require("pg-promise")();
const db = pgp("postgres://username:password@localhost:5432/database");

// Выполнение запроса UNION
db.query(
    `
  SELECT first_name, last_name
  FROM employees
  UNION
  SELECT first_name, last_name
  FROM contractors
`,
)
    .then((data) => {
        console.log("Результат запроса UNION:");
        console.log(data);
    })
    .catch((error) => {
        console.error("Ошибка выполнения запроса:", error);
    });
```

##### Выполнение подзапросов с помощью Node.js

Подзапросы позволяют включить один SQL запрос внутри другого запроса. Это полезно для создания более сложных запросов и фильтрации данных.

Пример выполнения подзапроса с использованием `pg-promise`:

```javascript
const pgp = require("pg-promise")();
const db = pgp("postgres://username:password@localhost:5432/database");

// Выполнение подзапроса
db.query(
    `
  SELECT first_name, last_name
  FROM employees
  WHERE department_id IN (
    SELECT department_id
    FROM departments
    WHERE department_name = 'IT'
  )
`,
)
    .then((data) => {
        console.log("Результат подзапроса:");
        console.log(data);
    })
    .catch((error) => {
        console.error("Ошибка выполнения запроса:", error);
    });
```

##### Продвинутые SQL операции и Node.js

Для выполнения других продвинутых SQL операций, таких как использование оконных функций, агрегации и аналитических функций, вам также понадобится библиотека `pg-promise` или аналогичная для удобной работы с PostgreSQL в Node.js.

## Транзакции

### Введение в транзакции

Транзакции - это важный аспект в управлении данными в SQL. Они представляют собой логические операции, которые могут быть выполнены как одно целое и либо успешно завершены, либо отменены в случае возникновения ошибок. Транзакции играют решающую роль в обеспечении целостности и надежности данных в базах данных.

#### Объяснение транзакций и их значения в управлении данными.

Транзакция в базе данных - это последовательность одного или нескольких SQL операторов, которые выполняются как единое целое. Транзакция либо выполняется успешно и сохраняет изменения в базе данных, либо откатывается, отменяя все изменения, сделанные во время транзакции.

Транзакции играют важную роль в обеспечении целостности данных. Они гарантируют, что база данных всегда остается в согласованном состоянии, даже в случае сбоев или ошибок во время выполнения операций. Если в рамках транзакции происходит ошибка, то все изменения, сделанные до этой ошибки, будут отменены, и база данных вернется в исходное состояние.

#### Преимущества использования транзакций.

1. **Целостность данных:** Транзакции обеспечивают целостность данных, предотвращая несогласованные изменения.
2. **Откат в случае ошибок:** В случае ошибок или сбоев выполнения, транзакции могут быть отменены (откачены), чтобы избежать некорректных изменений в базе данных.
3. **Согласованность:** Транзакции позволяют гарантировать согласованность данных, что особенно важно в многопользовательских средах.

### Работа с транзакциями в Node.js

#### Создание и управление транзакциями в Node.js

В Node.js можно использовать библиотеки, такие как `pg-promise` или `node-postgres`, для работы с PostgreSQL и управления транзакциями.

#### Создание транзакции

Для создания транзакции в Node.js необходимо выполнить следующие шаги:

1. Установите соответствующую библиотеку для работы с PostgreSQL, если она еще не установлена:

```bash
npm install pg-promise
```

2. Подключитесь к базе данных:

```javascript
const pgp = require("pg-promise")();
const db = pgp("postgres://username:password@localhost:5432/database");
```

3. Создайте транзакцию:

```javascript
db.tx(async (t) => {
    // Ваши SQL операции внутри транзакции
    await t.none("INSERT INTO table1 VALUES ($1, $2)", [value1, value2]);
    await t.none("UPDATE table2 SET column = $1 WHERE id = $2", [newValue, id]);
})
    .then((data) => {
        console.log("Транзакция выполнена успешно.");
    })
    .catch((error) => {
        console.error("Ошибка транзакции:", error);
    });
```

#### Коммит и откат транзакций

-   Коммит (commit): Если все операции внутри транзакции выполнены успешно, вызов `t.none` или других методов завершает транзакцию и сохраняет изменения в базе данных.
-   Откат (rollback): Если происходит ошибка в ходе транзакции или если вы явно вызываете `t.rollback`, то транзакция отменяется, и все изменения сбрасываются.

#### Практический пример

Давайте рассмотрим пример создания и управления транзакцией в Node.js:

Начнем с создания простой таблицы в PostgreSQL с использованием SQL:

```sql
CREATE TABLE employees (
    employee_id serial PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    hire_date DATE,
    salary numeric(10, 2)
);
```

В этом примере мы создаем таблицу с названием "employees", которая будет хранить информацию о сотрудниках. Каждый сотрудник будет иметь уникальный идентификатор `employee_id`, имя, фамилию, адрес электронной почты, дату найма и зарплату.

Примечание:

-   `serial` - это тип данных, который автоматически генерирует уникальные целочисленные значения для `employee_id`.
-   `PRIMARY KEY` определяет поле `employee_id` как первичный ключ таблицы, что гарантирует его уникальность.
-   `UNIQUE` для поля `email` гарантирует уникальность адресов электронной почты в таблице.
-   `numeric(10, 2)` - это числовой тип данных для поля `salary` с 10 цифрами, включая 2 знака после запятой для десятичных значений.

Теперь мы опишем транзакции.

```javascript
const pgp = require("pg-promise")();
const db = pgp("postgres://username:password@localhost:5432/database");

db.tx(async (t) => {
    try {
        await t.none("INSERT INTO users (name, email) VALUES ($1, $2)", [
            "John Doe",
            "john@example.com",
        ]);
        await t.none(
            "UPDATE accounts SET balance = balance + $1 WHERE user_id = $2",
            [100, 1],
        );
        console.log("Транзакция успешно завершена.");
    } catch (error) {
        t.rollback();
        console.error("Ошибка транзакции:", error);
    }
})
    .catch((error) => {
        console.error("Ошибка подключения к базе данных:", error);
    })
    .finally(() => {
        pgp.end();
    });
```

#### Основы коммита и отката транзакций.

Транзакция в SQL представляет собой набор одного или нескольких SQL операторов, которые выполняются как единое целое. Транзакции обеспечивают атомарность, целостность, изолированность и постоянство (ACID) операций в базе данных.

-   **Атомарность**: Все операции внутри транзакции либо выполняются успешно и сохраняют изменения, либо не выполняются вообще. Нет промежуточных состояний.
-   **Целостность**: Транзакция должна сохранять целостность данных. Если она не нарушает правил целостности, то изменения сохраняются. В противном случае транзакция откатывается (отменяется).
-   **Изолированность**: Транзакции выполняются изолированно друг от друга. Одна транзакция не видит изменения, сделанные в других транзакциях, до их завершения.
-   **Постоянство**: Если транзакция завершается успешно, её изменения сохраняются и переживают перезапуск системы.

##### **Коммит и откат транзакций**

-   **Коммит (COMMIT)**: Когда все операции внутри транзакции выполняются успешно, вы можете использовать оператор `COMMIT`, чтобы сохранить все изменения в базе данных. Это делает изменения постоянными и видимыми для других пользователей.

###### Синтаксис коммита

```sql
COMMIT;
```

-   **Откат (ROLLBACK)**: Если в ходе выполнения транзакции возникают проблемы или нарушается целостность данных, вы можете использовать оператор `ROLLBACK`, чтобы отменить все изменения и вернуть базу данных к предыдущему состоянию.

###### Синтаксис отката

```sql
ROLLBACK;
```

###### Пример использования коммита и отката

Рассмотрим пример использования коммита и отката в контексте транзакции:

```sql
BEGIN; -- Начало транзакции

UPDATE accounts
SET balance = balance - 100
WHERE account_id = 123;

-- Если произошла ошибка или нарушена целостность,
-- используем ROLLBACK для отмены изменений
-- ROLLBACK;

-- Если всё в порядке, используем COMMIT для сохранения изменений
-- COMMIT;
```

В этом примере мы начинаем транзакцию с помощью `BEGIN`, затем выполняем операции обновления баланса счета. Если всё прошло успешно, мы можем использовать `COMMIT`, чтобы сохранить изменения. Если возникла ошибка или проблема, мы можем использовать `ROLLBACK`, чтобы отменить изменения и вернуть базу данных к предыдущему состоянию.
